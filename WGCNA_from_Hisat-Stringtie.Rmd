---
title: "WGCNA_from_Hisat/Stringtie"
author: "Carlos Eduardo Madureira Trufen"
date: "4 de julho de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set working directory
```{r}
setwd("~/Dropbox/Script")
```


# Protein list
```{r, message=FALSE}
library("readr")
Haemophilus_influenzae_10810_GCF_000210875_1_proteintable <- read_delim("~/Dropbox/Script/Haemophilus_influenzae_10810.GCF_000210875.1.proteintable.txt", "\t", escape_double = FALSE, trim_ws = TRUE)

#Haemophilus_influenzae_10810_GCF_000210875_1_proteintable <- read_delim("C:/Users/3green/Dropbox/Script/Haemophilus_influenzae_10810.GCF_000210875.1.proteintable.txt", "\t", escape_double = FALSE, trim_ws = TRUE)
```

# Gene list
```{r, message=FALSE}
library('ballgown')
RefSeqgff <- gffRead("~/Dropbox/Script/GCF_000210875.1_ASM21087v1_genomic.gff")
#RefSeqgff <- gffRead("C:/Users/3green/Dropbox/Script/GCF_000210875.1_ASM21087v1_genomic.gff")
RefSeqgff.genes <- RefSeqgff[RefSeqgff[,3]=="gene",]
RefSeqgff.genes$Name <- getAttributeField(RefSeqgff.genes$attributes, "Name", attrsep = "; ")
RefSeqgff.genes$ID <- getAttributeField(RefSeqgff.genes$attributes, "ID", attrsep = "; ")
RefSeqgff.genes$OldLocusTag <- getAttributeField(RefSeqgff.genes$attributes, "old_locus_tag", attrsep = "; ")
RefSeqgff.genes$Gene_length = RefSeqgff.genes$end-RefSeqgff.genes$start
```

# Gff to GTF convertion
```{r, message=FALSE}
library(rtracklayer)
#Hibgff = import.gff3("~/Dropbox/Script/Haemophilus_influenzae_10810.ASM21087v1.36.gff3", "gff")
#Hibgff.genes <- Hibgff[Hibgff$type=="gene",]
#export(Hibgff,"~/Dropbox/Script/Hib_10810.gtf","gtf")
```

# Read in matrix from Hisat/Stringtie
```{r}
Stringtie_Count_Renamed_noRNA_table = read.csv("~/Dropbox/Dados_Alinhamento/Hisat_Stringtie/Stringtie_Count_Table_Renamed_without_rRNA.csv", header = TRUE, sep = "\t", row.names = 1)

Rsubread_Count_Renamed_noRNA_table = read.csv("~/Dropbox/Dados_Alinhamento/Rsubread_featurecounts/Rsubread_Count_Table_Renamed_without_rRNA.csv", header = TRUE, sep = "\t", row.names = 1)

Hib_Full_Rsubread_Trinity_salmon_without_rRNA = read.csv("~/Dropbox/Dados_Alinhamento/Rsubread_featurecounts/Hib_Full_Rsubread_Trinity_salmon_without_rRNA.csv", header = TRUE, sep = "\t", row.names = 1)


countData = Stringtie_Count_Renamed_noRNA_table
#countData = Stringtie_Count_Renamed_noRNA_table
#countData = cbind(countData[,1:3], countData[,5:7], countData[,9:11], countData[,13:15], countData[,17:19], countData[,21:23])
head(countData)
```

# Load packages
```{r, message=FALSE}
library("WGCNA")
library("cluster")
library("manipulate")
library("RUVSeq")
library("EDASeq")
options(stringsAsFactors = FALSE)
```

# Read in Hib Matrix form Stringtie alignment
```{r }
#stringtieCountData = Hibmatrix2 = read.csv("~/Dropbox/Dados_Alinhamento/Hisat_Stringtie/Stringtie_Count_Table_Renamed_without_rRNA.csv", header=TRUE, sep = "\t", row.names = 1)
```

# Sets design
```{r }
HibDesign1 = data.frame(row.names = colnames( countData ),
                        condition = rep(c("S01", "S02", "S03", "S04", "S05", "S06"), each = 4))
```


# least significantly DE genes based on a first-pass DE analysis performed prior to RUVg normalization.
```{r, message=FALSE}
library("edgeR")
group=as.factor(HibDesign1[,1])
design <- model.matrix(~ 0 + group)
colnames(design) <- levels(group)
rownames(design) = colnames(countData)
d <- DGEList(counts=countData, lib.size = colSums(countData), group=group)
d <- calcNormFactors(d , method="upperquartile")
d <- estimateDisp(d , design , tagwise=TRUE, robust=TRUE)
fit <- glmFit(d , design)
lrt <- glmLRT(fit ,coef=2:6)
top <-   topTags(lrt, n=nrow(d))$table
empirical <-   rownames(countData)[which(!(rownames(countData) %in% rownames(top)[1:500]))]
```

# Here, we consider all but the top 500 genes as ranked by edgeR p-values
```{r }
# The RUVg function  returns  two  pieces  of  information:
# the estimated factors of unwanted variation nd the normalized counts obtained by regressing the original counts on the unwanted factors
# The normalized values are stored in the normalizedCounts slot
set2 <- RUVg(as.matrix(d), empirical, k=1)
```

# plotRLE creates relative log expression (RLE) plot, initially proposed to measure the overall quality of a dataset 
# plotRLE can also be used to visualize the presence of unwanted batch effects in the data
```{r }
col.cell <- c("purple","orange", "blue", "red", "green", "black")[as.factor(HibDesign1[,1])]
par(mfrow=c(1,2))
plotRLE(as.matrix(countData), outline=FALSE, ylim=c(-4, 4), col=col.cell)
plotRLE(set2$normalizedCounts, outline=FALSE, ylim=c(-4, 4), col=col.cell)
```

# Set design, removing batch effect
```{r}
HibDesign2 = data.frame(row.names = colnames( countData ), condition = rep(c("S01", "S02", "S03", "S04", "S05", "S06"), each = 4),  set2$W)
design = model.matrix(~group+set2$W, data = HibDesign2)
colnames(design) <- c(levels(group), "W")
group=as.factor(HibDesign2[,1])
```

#Pre-processing
```{r}
# We do not recommend filtering genes by differential expression. WGCNA is designed to be an unsupervised analysis method that clusters genes based on their expression profiles. Filtering genes by differential expression will lead to a set of correlated genes that will essentially form a single (or a few highly correlated) modules. It also completely invalidates the scale-free topology assumption, so choosing soft thresholding power by scale-free topology fit will fail. 
```

# TMM normaliztion from edgeR
```{r}
library("edgeR")
d <- DGEList(counts=countData, lib.size = colSums(countData), group=group)
WGCNAremove = which(rowSums(d$counts==0)==24)
WGCNAfiltered <- d[-WGCNAremove,]
dim(WGCNAfiltered)
WGCNAtmm <- calcNormFactors(WGCNAfiltered , "TMM")
WGCNAtpm = cpm(WGCNAtmm, normalized.lib.sizes=TRUE)
head(WGCNAtpm)
```

# Transpose the expression data for further analysis
# Henceforth, each row will correspond to a sample and each column to a gene
```{r}
datExpr0 = as.data.frame(t(WGCNAtpm))
```

# Transpose the expression data for further analysis
# Henceforth, each row will correspond to a sample and each column to a gene
```{r}
blockwiseModules(datExpr0)
```


# cluster the samples to see if there are any obvious outliers.
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
```{r}
sampleTree = hclust(dist(datExpr0), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
abline(h = 1, col = "red") # Plot a line to show the cut
```

# Determine cluster under the line
```{r}
clust = cutreeStatic(sampleTree, cutHeight = 250000, minSize = 10)
table(clust)
```

# clust contains the samples we want to keep.
```{r}
keepSamples = (clust==1)
datExpr = datExpr0[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
```

# To compare samples 2 by 2, 3 by 3..
```{r}
nSets = 14
multiExpr = vector(mode = "list", length = nSets)
g = function(j) {if (j==0){result = 0}
  else {result = sum(5-(1:j-1))}
  return(result)}
for (j in 0:3){for (i in 1:(5-j)){multiExpr[[i+g(j)]] = list(data = datExpr[(4*i-3):(4*i+4*j+4),])}}

```

# Constructing a weighted gene network entails the choice of the soft thresholding power to which co-expression similarity is raised to calculate adjacency
```{r}
# The choice for soft thresholding power is based on the criterion of approximate scale-free topology.
#Choose a set of soft-thresholding powers
powers = c(c(2:10), seq(from = 12, to=30, by=2))
```

# Call the network topology analysis function
```{r}
# Let p(dk) be the frequency distribution 
# scale-free topology fitting index measures the extent of a straight line relationship between log(p(r)) and log(r)
# scale-free topology fitting index is defined as the square of the correlation coefficient between log(p(dk)) and log(BinNo)
# Networks whose scale-free topology index R2 is close to 1 are defined to be approximately scale free.
# connectivity distribution p(r) may be better moduled using an Exponentially truncated power law: p(r) = PositiveNumber*r^(-?)*exp(-ar); ? and a positive real numbers 
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 2)
softPower = sft$fitIndices[min(which(sft$fitIndices[,2]>0.8)),1]
if (is.na(softPower)==TRUE){softPower=10}
```

# Plot the results:
```{r, fig.width=9, fig.height=5}
par(mfrow = c(1,2))
cex1 = 0.9
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n", main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.80,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

```{r}
datExpr <- apply(datExpr, c(1, 2), as.numeric)
```

# Co-expression similarity and adjacency
```{r}
# The relationship between R2 and the threshold parameter (t or ? ) follows approximately a saturation curve
# The refined scale-free topology criterion: 
# use the first threshold parameter value where saturation is reached as long as it is above 0.8
# We now calculate the adjacencies, using the soft thresholding power 
# n?n dimensional adjacency matrix A = (Aij), where the entry Aij quantifies the connection strength from node i to node j
# For a weighted network, Aij takes on a real number between 0 and 1
# The power adjacency function changes the topological properties (network concepts) of weighted networks
adjacency = adjacency(datExpr, power = softPower)
```

# Evaluate the scale free topology fit of the network
```{r, message=FALSE}
# The function scaleFreePlot() plots a log-log plot of a histogram of the given connectivities, and fits a linear model plus optionally a truncated exponential model
# The R2 of the fit can be considered an index of the scale freedom of the network topology
par(mfrow = c(1,1))
scaleFreePlot(adjacency , truncated = TRUE, main="Scale Free Topology")
```

# Topological Overlap Matrix (TOM)
```{r, message=FALSE}
# To minimize effects of noise and spurious associations, we transform the adjacency into Topological Overlap Matrix, and calculate the corresponding dissimilarity
# We will use the topological overlap measure as robust measure of interconnectedness
# The function TOMsimilarity() takes as input a weighted (or possibly unweighted) adjacency matrix and outputs the first order (m=1) GTOMmeasure
# This function cannot calculate higher order (m > 1) generalizations of the TOM measure
# Turn adjacency into topological overlap
TOM = TOMsimilarity(adjacency)
dissTOM = 1-TOM
```

# Clustering using TOM
```{r}
# use the TOM-based dissimilarity as input of average linkage hierarchical clustering
# which results in a cluster tree (dendrogram) of the network
# Call the hierarchical clustering function hclust() to produce a hierarchical clustering tree (dendrogram) of genes
geneTree = hclust(as.dist(dissTOM), method = "average")
```

# Plot the resulting clustering tree (dendrogram)
```{r, fig.width=7, fig.height=7}
# In the clustering tree (dendrogram), each leaf, that is a short vertical line, corresponds to a gene.
# Gene modules are defined as branches of the hierarchical clustering tree (dendrogram)
# Branches of the dendrogram group together densely interconnected, highly co-expressed genes.
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity", labels = FALSE, hang = 0.04)
```


# Set the minimum module size to 22 (= total genes in gene sets(2006)/ number of gene sets(90):
```{r}
library("gage")
kegg.gs = kegg.gsets(species = "hiu", id.type = "kegg")

nHibgenes = vector(mode = "list", length = length(kegg.gs$kg.sets))
for (i in 1:length(kegg.gs$kg.sets)){nHibgenes[[i]] = summary(table(kegg.gs$kg.sets[i]))}

ngenes = matrix(, nrow = 90, ncol = 1)
for (i in 1:length(kegg.gs$kg.sets)){ngenes[i,1] = (nHibgenes[[i]]$n.cases)}

media = sum(ngenes)/length(kegg.gs$kg.sets)
```

# Criteria to define minimum module size: least value to cluster all Hib polysaccharide synthesis genes
```{r}
minModuleSize = 61
```


# Module identification using dynamic tree cut:
```{r}
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = minModuleSize)
table(dynamicMods)
```

# Convert numeric lables into colors
```{r}
dynamicColors = labels2colors(dynamicMods)
```

# Genes of proper modules (branches) are assigned a color
# Genes outside any proper module are colored gray
```{r}
table(dynamicColors)
```

# Genes in modules
```{r, message=FALSE}
library(dplyr)
dynamicColors1 = as.matrix(dynamicColors)
rownames(dynamicColors1) = rownames(adjacency)
premoduleblocks =  vector(mode = "list", length = length(table(dynamicColors)))
for (i in 1:length(table(dynamicColors1))){premoduleblocks[[i]] = as.matrix(dynamicColors1[which(dynamicColors1==names(table(dynamicColors1))[i]),1])}

#for(i in 1:length(table(dynamicColors1))){print(rownames(premoduleblocks[[i]]))}
```

# Check if genes for polysaccharide synthesis are in the same module
```{r, meddage=FALSE}
# Polysaccharide polymerase (HIB_10030) (HIB_RS05310)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_10030" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# short-chain dehydrogenases/reductases family protein - ribitol-5-phosphate 2-dehydrogenase (NADP+) / D-ribitol-5-phosphate cytidylyltransferase (bcs1) (HIB_11690) (HIB_RS06115)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11690" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# short-chain dehydrogenases/reductases family protein - ribitol-5-phosphate 2-dehydrogenase (NADP+) / D-ribitol-5-phosphate cytidylyltransferase (bcs1) (HIB_11840) (HIB_RS06180)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11840" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase - dna for serotype b capsulation locus (bcs2) (HIB_11830) (HIB_RS06175)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11830" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase - dna for serotype b capsulation locus (bcs2) (HIB_11680) (HIB_RS06110)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11680" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase (bcs3) (HIB_11670) (HIB_RS06105)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11670" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase (bcs3) (HIB_11820) (HIB_RS06170)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11820" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide biosynthesis protein (bcs4) (HIB_11660) (HIB_RS06100)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11660" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide biosynthesis protein (bcs4) (HIB_11810) (HIB_RS06165)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11810" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}
```


# Check if genes polysaccharide related are in the same module
```{r, meddage=FALSE}
# Polysaccharide polymerase
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_10030" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide biosynthesis protein
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11810" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide export inner-membrane protein (bexB)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11720" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide export inner-membrane protein (bexB)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11870" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide transporter - capsular polysaccharide transport system permease protein (bexC)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11710" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide transporter - capsular polysaccharide transport system permease protein (bexC)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11860" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# sugar ABC transporter substrate-binding protein - polysaccharide biosynthesis/export protein (bexD)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11850" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# short-chain dehydrogenase - ribitol-5-phosphate 2-dehydrogenase (NADP+) / D-ribitol-5-phosphate cytidylyltransferase (bcs1)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11690" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# short-chain dehydrogenase - ribitol-5-phosphate 2-dehydrogenase (NADP+) / D-ribitol-5-phosphate cytidylyltransferase (bcs1)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11840" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase - dna for serotype b capsulation locus (bcs2)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11830" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase (bcs3)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11670" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase (bcs3)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11820" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide biosynthesis protein (bcs4)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11660" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsA)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11650" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsA)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11800" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsB)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11640" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsB)
for(i in 1:length(table(dynamicColors1))){
  if ("HIB_11790" %in% rownames(premoduleblocks[[i]])==TRUE){
    print(i)
  }
}
```

# Plot the dendrogram and colors underneath
```{r, fig.width=7, fig.height=7}
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors")

```

# Merging of modules whose expression profiles are very similar
```{r}
# Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
```

# Calculate dissimilarity of module eigengenes
```{r}
MEDiss = 1-cor(MEs)
```

# Cluster module eigengenes
```{r}
METree = hclust(as.dist(MEDiss), method = "average")
```

# Plot the result
```{r, fig.width=7, fig.height=7}
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
```

# We choose a height cut of 0.25 to merge, corresponding to correlation of 0.75.
```{r}
MEDissThres = 0.25
#which(MEDiss <MEDissThres)
#MEDiss[which(MEDiss <MEDissThres)]
```

# Plot the cut line into the dendrogram
```{r, fig.width=7, fig.height=7}
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
MEDissThres = 0.25
abline(h=MEDissThres, col = "red")
```

# Call an automatic merging function
```{r}
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
```

```{r}
merge$newMEs
```

# The merged module colors
```{r}
mergedColors = merge$colors;
```

# Eigengenes of the new merged modules:
```{r}
mergedMEs = merge$newMEs;
```

# plot the gene dendrogram again, with the original and merged module colors underneath
```{r, fig.width=7, fig.height=7}
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
```

# plot the gene dendrogram again, with the original and merged module colors underneath
```{r, fig.width=7, fig.height=7}
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
```

# In the subsequent analysis, we will use the merged module colors in mergedColors.
```{r}
## We save the relevant variables for use in subsequent steps
# Rename to moduleColors
moduleColors = mergedColors
table(moduleColors)
```

# Construct numerical labels corresponding to the colors
```{r}
colorOrder = c("grey", standardColors(50))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs
```

# Gene ID in each module
```{r}
moduleColors1 = as.matrix(moduleColors)
rownames(moduleColors1) = colnames(datExpr)
moduleblocks = vector(mode = "list", length = length(merge$newMEs)) # length(merge$newMEs) ? n?mero de clusters encontrados
for (i in 1:length(merge$newMEs)){moduleblocks[[i]] = as.matrix(moduleColors1[which(moduleColors1==gsub("ME","",names(merge$newMEs)[i])),1])} # genes de cada cor id de cluster fica armazenado em vetor diferente da lista; gsub para retirar as letras ME do id da cor do m?dulo

for(i in 1:length(merge$newMEs)){print(rownames(moduleblocks[[i]]))} # quais genes est?o em cada cluster

```

# Standard gene screening based on marginal correlation
# Relating modules and module eigengenes to external data
```{r}
# how related the modules are
datME=moduleEigengenes(datExpr,moduleColors)$eigengenes
signif(cor(datME, use="p"), 2)
```

# We define a dissimilarity measure between the module eigengenes  that keeps track of the sign of the correlation between the module eigengenes, and use it to cluster the eigengene
```{r, fig.width=7, fig.height=7}
dissimME=(1-t(cor(datME, method="p")))/2
hclustdatME=hclust(as.dist(dissimME), method="average" )
# Plot the eigengene dendrogram
par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based of the module eigengenes")
```

# from Dados_Cultivo.R
# Data input and formating
```{r}
HibPP = lapply(6:8, function(i){read.csv(paste0("~/Dropbox/Script/HibPP0", i, "-16.csv"), dec = ",",  sep = "\t", header = TRUE, quote = "")})
HibPP[[4]] = read.csv("~/Dropbox/Script/HibPP02-17.csv", dec = ",", header=TRUE, sep="\t", quote="")
points = c(3, 9, 11, 12, 16, 21)
cores = c("blue", "red", "black", "purple", "magenta", "darkblue")
```

# EFT
```{r}
EFT = lapply(1:4, function(i){HibPP[[i]][,2]})
EFTv = lapply(1:4, function(i){as.numeric(sub(",", ".", EFT[[i]], fixed = TRUE))})
EFTs = lapply(1:4, function(i){EFTv[[i]][points]})
xmax = max(unlist(lapply(EFTv,FUN=max,na.rm=TRUE)))
```

# DeltaEFT
```{r}
DeltaEFT = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaEFT[[i]][j] = EFTv[[i]][j]-EFTv[[i]][j-1]}}
```

# [CO2]
```{r, message=FALSE}
CO2 = lapply(1:4, function(i){HibPP[[i]][,9]})
CO2[] <- lapply(CO2, as.character)
CO2sem = lapply(1:4, function(i){substr(CO2[[i]], 1, nchar(CO2[[i]])-1)})
CO2v = lapply(1:4, function(i){as.numeric(sub(",", ".", CO2sem[[i]], fixed = TRUE))})
CO2s = lapply(1:4, function(i){CO2v[[i]][points]})
CO2t = as.vector(sapply(1:4, function(i){cbind(CO2s[[i]])}))

max_y = max(unlist(lapply(CO2v,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], CO2v[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de CO2 (%)", main = "Concentração de CO2 durante o cultivo", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(CO2v[[i]], type="o", pch=20+i, lty = i, col=cores[i])  
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("bottomright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)

```

# DeltaCO2
```{r}
DeltaCO2 = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaCO2[[i]][j] = CO2v[[i]][j]-CO2v[[i]][j-1]}}
```

# [O2]
```{r}
O2 = lapply(1:4, function(i){HibPP[[i]][,7]})
O2[] <- lapply(O2, as.character)
O2sem = lapply(1:4, function(i){substr(O2[[i]], 1, nchar(O2[[i]])-1)})
O2v = lapply(1:4, function(i){as.numeric(sub(",", ".", O2sem[[i]], fixed = TRUE))})
O2s = lapply(1:4, function(i){O2v[[i]][points]})
O2t = as.vector(sapply(1:4, function(i){cbind(O2s[[i]])}))

max_y = max(unlist(lapply(O2v,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], O2v[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de O2 (%)", main = "Concentração de O2 durante o cultivo", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(O2v[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# DeltaO2
```{r}
DeltaO2 = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaO2[[i]][j] = O2v[[i]][j]-O2v[[i]][j-1]}}
```

# [Acetato]
```{r}
Acetato = lapply(1:4, function(i){HibPP[[i]][,13]})
Acetatov = lapply(1:4, function(i){as.numeric(sub(",", ".", Acetato[[i]], fixed = TRUE))})
Acetatos = lapply(1:4, function(i){Acetatov[[i]][points]})
Acetatot = as.vector(sapply(1:4, function(i){cbind(Acetatos[[i]])}))

max_y = max(unlist(lapply(Acetatov,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], Acetatov[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de Acetato (g/L)", main = "Concentração de Acetato produzido", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend(1, max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# DeltaAcetato
```{r}
DeltaAcetato = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaAcetato[[i]][j] = Acetatov[[i]][j]-Acetatov[[i]][j-1]}}
```

# [PRP]
```{r}
PRP = lapply(1:4, function(i){HibPP[[i]][,15]})
PRPv = lapply(1:4, function(i){as.numeric(sub(",", ".", PRP[[i]], fixed = TRUE))})
PRPs = lapply(1:4, function(i){PRPv[[i]][points]})
PRPt = as.vector(sapply(1:4, function(i){cbind(PRPs[[i]])}))

max_y = max(unlist(lapply(PRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], PRPv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de PRP (g/L)", main = "Concentração de PRP produzido", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend(1, max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# DeltaPRP
```{r}
DeltaPRP = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaPRP[[i]][j] = PRPv[[i]][j]-PRPv[[i]][j-1]}}
```

# Biomassa Seca
```{r}
Massa = lapply(1:4, function(i){HibPP[[i]][,11]})
Massav = lapply(1:4, function(i){as.numeric(sub(",", ".", Massa[[i]], fixed = TRUE))})
Massas = lapply(1:4, function(i){Massav[[i]][points]})
Massat = as.vector(sapply(1:4, function(i){cbind(Massas[[i]])}))

max_y = max(unlist(lapply(Massav,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], Massav[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de Biomassa (g/L)", main = "Concentração de Biomassa", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(Massav[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend(1, max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# DeltaMassa
```{r}
DeltaMassa = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaMassa[[i]][j] = Massav[[i]][j]-Massav[[i]][j-1]}}
```

# [Glicose]
```{r}
# 
Glicose = lapply(1:4, function(i){HibPP[[i]][,12]})
Glicosev = lapply(1:4, function(i){as.numeric(sub(",", ".", Glicose[[i]], fixed = TRUE))})
Glicoses = lapply(1:4, function(i){Glicosev[[i]][points]})
Glicoset = as.vector(sapply(1:4, function(i){cbind(Glicoses[[i]])}))

max_y = max(unlist(lapply(Glicosev,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], Glicosev[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de Glicose (g/L)", main = "Concentração de Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(Glicosev[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# [ConsumoGlicose]
```{r}
# 
CGlicose = lapply(1:4, function(i){HibPP[[i]][,21]})
CGlicosev = lapply(1:4, function(i){as.numeric(sub(",", ".", CGlicose[[i]], fixed = TRUE))})
CGlicoses = lapply(1:4, function(i){CGlicosev[[i]][points]})
CGlicoset = as.vector(sapply(1:4, function(i){cbind(CGlicoses[[i]])}))

max_y = max(unlist(lapply(CGlicosev,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], CGlicosev[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Concentração de Glicose Consumida (g/L)", main = "Concentração de Glicose Consumida", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(CGlicosev[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


# DeltaGlicose
```{r}
DeltaGlicose = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaGlicose[[i]][j] = Glicosev[[i]][j]-Glicosev[[i]][j-1]}}
```

# DeltaCGlicose
```{r}
DeltaCGlicose = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaCGlicose[[i]][j] = CGlicosev[[i]][j]-CGlicosev[[i]][j-1]}}
```

# [MM]
```{r}
MM = lapply(1:4, function(i){HibPP[[i]][,16]})
MMv = lapply(1:4, function(i){as.numeric(sub(",", ".", MM[[i]], fixed = TRUE))})
MMs = lapply(1:4, function(i){MMv[[i]][points]})
MMt = as.vector(sapply(1:4, function(i){cbind(MMs[[i]])}))
```

# velocidades instantaneas de crescimento/ Crescimento específico
```{r}
rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
rxv = lapply(1:4, function(i){rx[,i]})

max_y = max(unlist(lapply(rxv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rxv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rxv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Crescimento Específico de Biomsassa (g/L)", main = "Crescimento Específico de Biomsassa", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(rxv[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# velocidades instantaneas de consumo de substrato
```{r}
rsG = -1*(cbind(DeltaCGlicose[[1]]/DeltaEFT[[1]], DeltaCGlicose[[2]]/DeltaEFT[[2]], DeltaCGlicose[[3]]/DeltaEFT[[3]], DeltaCGlicose[[4]]/DeltaEFT[[4]]))

rsGv = lapply(1:4, function(i){rsG[,i]})

max_y = max(unlist(lapply(rsGv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rsGv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rsGv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Consumo de Substrato (g/L)", main = "Velocidade Instantanea de Consumo de Substrato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(rsGv[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# velocidades instantaneas de formacao de produto (PRP)
```{r}
rsPRP = cbind(DeltaPRP[[1]]/DeltaEFT[[1]], DeltaPRP[[2]]/DeltaEFT[[2]], DeltaPRP[[3]]/DeltaEFT[[3]], DeltaPRP[[4]]/DeltaEFT[[4]])

rsPRPv = lapply(1:4, function(i){rsPRP[,i]})

max_y = max(unlist(lapply(rsPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rsPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rsPRPv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Formação de PRP ((g/L)/h)", main = "Velocidade Instantanea de Formação de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(rsPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# velocidades instantaneas de formacao de produto (Acetato)
```{r}
rsAc = cbind(DeltaAcetato[[1]]/DeltaEFT[[1]], DeltaAcetato[[2]]/DeltaEFT[[2]], DeltaAcetato[[3]]/DeltaEFT[[3]], DeltaAcetato[[4]])

rsAcv = lapply(1:4, function(i){rsAc[,i]})

max_y = max(unlist(lapply(rsAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rsAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rsAcv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Formação de Acetato ((g/L)/h)", main = "Velocidade Instantanea de Formação de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(rsAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# produtividade em biomassa -> velocidade media de crescimento referente ao tempo .total ou final de fermentacao
```{r}
Px = cbind((Massav[[1]]-Massav[[1]][2])/EFT[[1]], (Massav[[2]]-Massav[[2]][2])/EFT[[2]],(Massav[[3]]-Massav[[3]][2])/EFT[[3]],(Massav[[4]]-Massav[[4]][2])/EFT[[4]])

Pxv = lapply(1:4, function(i){Px[,i]})

max_y = max(unlist(lapply(Pxv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
#min_y = min(unlist(lapply(Pxv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], Pxv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Produtividade em Biomassa ((g/L)/h)", main = "Velocidade Instantanea de Crescimento referente ao tempo", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
for (i in 2:4){lines(Pxv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# produtividade do produto (PRP)
```{r}
PpPRP = cbind((PRPv[[1]]-PRPv[[1]][7])/EFT[[1]], (PRPv[[2]]-PRPv[[2]][7])/EFT[[2]],(PRPv[[3]]-PRPv[[3]][1])/EFT[[3]],(PRPv[[4]]-PRPv[[4]][1])/EFT[[4]])

PpPRP[1,1] = PpPRP[1,2] = PpPRP[1,3] = PpPRP[1,4] = NA

PpPRPv = lapply(1:4, function(i){PpPRP[,i]})

max_y = max(unlist(lapply(PpPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(PpPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], PpPRPv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Produtividade de PRP ((g/L)/h)", main = "Produtividade de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(PpPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# produtividade do produto (Acetato)
```{r}
PpAc = cbind((Acetatov[[1]]-Acetatov[[1]][1])/EFT[[1]], (Acetatov[[2]]-Acetatov[[2]][1])/EFT[[2]],(Acetatov[[3]]-Acetatov[[3]][1])/EFT[[3]],(Acetatov[[4]]-Acetatov[[4]][1])/EFT[[4]])

PpAcv = lapply(1:4, function(i){PpAc[,i]})

max_y = max(unlist(lapply(PpAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(PpAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], PpAcv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Produtividade de Acetato ((g/L)/h)", main = "Produtividade de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
box() # Create box around plot
for (i in 2:4){lines(PpAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# velocidades especificas de transformacao
```{r}
# velocidades especificas de crescimento
MiX = cbind(rx[,1]/Massav[[1]],rx[,2]/Massav[[2]],rx[,3]/Massav[[3]],rx[,4]/Massav[[4]])

MiXv = lapply(1:4, function(i){MiX[,i]})

max_y = max(unlist(lapply(MiXv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiXv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiXv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Velocidade Específica de Crescimento ((g/L)/h)", main = "Velocidade Específica de Crescimento", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(MiXv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


# velocidades especificas de transformacao
```{r}
# velocidades especificas de consumo de substrato
MiS = -1*cbind(rsG[,1]/Massav[[1]],rsG[,2]/Massav[[2]],rsG[,3]/Massav[[3]],rsG[,4]/Massav[[4]])

MiSv = lapply(1:4, function(i){MiS[,i]})

max_y = max(unlist(lapply(MiSv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiSv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiSv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Velocidade Específica de Consumo de Substrato g.L¹.h¹", main = "Velocidade Específica de Consumo de Substrato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(MiSv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


# velocidades especificas de transformacao
```{r}
# velocidades especificas de formacao de produto
MiPAc = cbind(rsAc[,1]/Massav[[1]],rsAc[,2]/Massav[[2]],rsAc[,3]/Massav[[3]],rsAc[,4]/Massav[[4]])

MiPAcv = lapply(1:4, function(i){MiPAc[,i]})

max_y = max(unlist(lapply(MiPAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiPAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiPAcv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Velocidade Específica de Formação de Acetato (g.L¹.h¹)", main = "Velocidade Específica de Formação de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(MiPAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```



# velocidades especificas de transformacao
```{r}
# velocidades especificas de formacao de produto
MiPPRP = cbind(rsPRP[,1]/Massav[[1]],rsPRP[,2]/Massav[[2]],rsPRP[,3]/Massav[[3]],rsPRP[,4]/Massav[[4]])

MiPPRPv = lapply(1:4, function(i){MiPPRP[,i]})

max_y = max(unlist(lapply(MiPPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiPPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiPPRPv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Velocidade Específica de Formação de PRP (g.L¹.h¹)", main = "Velocidade Específica de Formação de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(MiPPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
Yxs = -1*(cbind(DeltaMassa[[1]]/DeltaCGlicose[[1]],DeltaMassa[[2]]/DeltaCGlicose[[2]],DeltaMassa[[3]]/DeltaCGlicose[[3]],DeltaMassa[[4]]/DeltaCGlicose[[4]]))

Yxsv = lapply(1:4, function(i){Yxs[,i]})

max_y = max(unlist(lapply(Yxsv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(Yxsv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], Yxsv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Coeficiente Específico de Biomassa/Glicose", main = "Coeficiente Específico de Biomassa/Glicose", col = cores[1],  xlim=c(1, xmax), ylim=c(-10, max_y))
box() # Create box around plot
for (i in 2:4){lines(Yxsv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
YxpAc = cbind(DeltaMassa[[1]]/DeltaAcetato[[1]],DeltaMassa[[2]]/DeltaAcetato[[2]],DeltaMassa[[3]]/DeltaAcetato[[3]],DeltaMassa[[4]]/DeltaAcetato[[4]])

YxpAcv = lapply(1:4, function(i){YxpAc[,i]})

max_y = max(unlist(lapply(YxpAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YxpAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YxpAcv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Coeficiente Específico de Biomassa/Acetato", main = "Coeficiente Específico de Biomassa/Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(YxpAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
YxpPRP = cbind(DeltaMassa[[1]]/DeltaPRP[[1]],DeltaMassa[[2]]/DeltaPRP[[2]],DeltaMassa[[3]]/DeltaPRP[[3]],DeltaMassa[[4]]/DeltaPRP[[4]])

YxpPRPv = lapply(1:4, function(i){YxpPRP[,i]})

max_y = max(unlist(lapply(YxpPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YxpPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YxpPRPv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Coeficiente Específico de Biomassa/PRP", main = "Coeficiente Específico de Biomassa/PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
box() # Create box around plot
for (i in 2:4){lines(YxpPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
YpsAc = -1*(cbind(DeltaAcetato[[1]]/DeltaCGlicose[[1]],DeltaAcetato[[2]]/DeltaCGlicose[[2]],DeltaAcetato[[3]]/DeltaCGlicose[[3]],DeltaAcetato[[4]]/DeltaCGlicose[[4]]))

YpsAcv = lapply(1:4, function(i){YpsAc[,i]})

max_y = max(unlist(lapply(YpsAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YpsAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YpsAcv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Coeficiente Específico de Acetato/Glicose", main = "Coeficiente Específico de Acetato/Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(-100, max_y))
box() # Create box around plot
for (i in 2:4){lines(YpsAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
YpsPRP = -1*(cbind(DeltaPRP[[1]]/DeltaCGlicose[[1]],DeltaPRP[[2]]/DeltaCGlicose[[2]],DeltaPRP[[3]]/DeltaCGlicose[[3]],DeltaPRP[[4]]/DeltaCGlicose[[4]]))

YpsPRPv = lapply(1:4, function(i){YpsPRP[,i]})

max_y = max(unlist(lapply(YpsPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YpsPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YpsPRPv[[1]], type="o", pch=21, lty = 1, xlab="EFT(h)", ylab="Coeficiente Específico de PRP/Glicose", main = "Coeficiente Específico de PRP/Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(-5, max_y))
box() # Create box around plot
for (i in 2:4){lines(YpsPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.5, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# Dados
```{r}
sDados = vector(mode = "list", length = 24)
sDados[[1]] = cbind(Massas[[1]], Massas[[2]], Massas[[3]], Massas[[4]])
sDados[[2]] = cbind(Acetatos[[1]], Acetatos[[2]], Acetatos[[3]], Acetatos[[4]])
sDados[[3]] = cbind(Glicoses[[1]], Glicoses[[2]], Glicoses[[3]], Glicoses[[4]])
sDados[[4]] = cbind(PRPs[[1]], PRPs[[2]], PRPs[[3]], PRPs[[4]])
sDados[[5]] = cbind(CO2s[[1]],CO2s[[2]], CO2s[[3]], CO2s[[4]])
sDados[[6]] = cbind(O2s[[1]], O2s[[2]], O2s[[3]], O2s[[4]])
sDados[[7]] = cbind(rx[,1][points], rx[,2][points], rx[,3][points], rx[,4][points])
sDados[[8]] = cbind(rsG[,1][points], rsG[,2][points], rsG[,3][points], rsG[,4][points])
sDados[[9]] = cbind(rsPRP[,1][points], rsPRP[,2][points], rsPRP[,3][points], rsPRP[,4][points])
sDados[[10]] = cbind(rsAc[,1][points], rsAc[,2][points], rsAc[,3][points], rsAc[,4][points])
sDados[[11]] = cbind(Px[,1][points], Px[,2][points], Px[,3][points], Px[,4][points])
sDados[[12]] = cbind(PpAc[,1][points], PpAc[,2][points], PpAc[,3][points], PpAc[,4][points])
sDados[[13]] = cbind(PpPRP[,1][points], PpPRP[,2][points], PpPRP[,3][points], PpPRP[,4][points])
sDados[[14]] = cbind(MiX[,1][points], MiX[,2][points], MiX[,3][points], MiX[,4][points])
sDados[[15]] = cbind(MiS[,1][points], MiS[,2][points], MiS[,3][points], MiS[,4][points])
sDados[[16]] = cbind(MiPAc[,1][points], MiPAc[,2][points], MiPAc[,3][points], MiPAc[,4][points])
sDados[[17]] = cbind(MiPPRP[,1][points], MiPPRP[,2][points], MiPPRP[,3][points], MiPPRP[,4][points])
sDados[[18]] = cbind(Yxs[,1][points], Yxs[,2][points], Yxs[,3][points], Yxs[,4][points])
sDados[[19]] = cbind(YxpAc[,1][points], YxpAc[,2][points], YxpAc[,3][points], YxpAc[,4][points])
sDados[[20]] = cbind(YxpPRP[,1][points], YxpPRP[,2][points], YxpPRP[,3][points], YxpPRP[,4][points])
sDados[[21]] = cbind(YpsAc[,1][points], YpsAc[,2][points], YpsAc[,3][points], YpsAc[,4][points])
sDados[[22]] = cbind(YpsPRP[,1][points], YpsPRP[,2][points], YpsPRP[,3][points], YpsPRP[,4][points])
sDados[[23]] = cbind(MMs[[1]], MMs[[2]], MMs[[3]], MMs[[4]])
sDados[[24]] = cbind(CGlicoses[[1]], CGlicoses[[2]], CGlicoses[[3]], CGlicoses[[4]])
```

# tDados
```{r}
tDados = vector(mode = "list", length = length(sDados))
for (i in 1:length(sDados)){tDados[[i]] = append(sDados[[i]][1,], unlist(lapply(2:6, function(j){sDados[[i]][j,]})))} # Samples data traits

```

# Pairwise scatter plots of the samples (arrays) along the module eigengenes
```{r, fig.width=7, fig.height=7}
# The function plotMEpairs() produces a matrix of plots containing pairwise scatterplots of given eigengenes, the distribution of their values and their pairwise correlations.
# The function plotMEpairs() produces an NxN matrix of plots, where N is the number of eigengenes. 
# In the upper triangle it plots pairwise scatterplots of module eigengenes (plus the trait y, if given).
# On the diagonal it plots histograms of sample values for each eigengene. 
# Below the diagonal, it displays the pairwise correlations of the eigengenes
# datME is a data frame containing expression data, with rows corresponding to samples and columns to genes. Missing values are allowed and will be ignored.
# y is an optional sample trait vector. It will be treated as an additional eigengene.
# clusterMEs -> logical: should the module eigengenes be ordered by their dendrogram?
plotMEpairs(datME,y=tDados[[13]], clusterMEs = TRUE)
```

# Diagnostics: heatmap plots of module expression
```{r, fig.width=7, fig.height=7}
# We now create a heatmap plots of module expressions.
par(mfrow=c(3,2), mar=c(1, 2, 4, 1))

which.module=gsub("ME","",names(merge$newMEs)[1]) #which.module="darkturquoise"
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module, title=which.module )

which.module=gsub("ME","",names(merge$newMEs)[2]) #which.module="darkmagenta";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module, title=which.module )

which.module=gsub("ME","",names(merge$newMEs)[3]) #which.module="green";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module, title=which.module )

which.module=gsub("ME","",names(merge$newMEs)[4]) #which.module="green";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module, title=which.module )

which.module=gsub("ME","",names(merge$newMEs)[5]) #which.module="green";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module, title=which.module )

```

# Diagnostics: displaying module heatmap and the eigengene
```{r, fig.width=7, fig.height=7}
which.module=gsub("ME","",names(merge$newMEs)[1]) #which.module="darkturquoise" #which.module="green"
ME=datME[, paste("ME",which.module, sep="")]
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ), nrgcols=30,rlabels=F,rcols=which.module, main=which.module, cex.main=2)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2, ylab="eigengene expression",xlab="sample")

```


# Diagnostics: displaying module heatmap and the eigengene
```{r, fig.width=7, fig.height=7}
which.module=gsub("ME","",names(merge$newMEs)[2]) #which.module="darkturquoise" #which.module="green"
ME=datME[, paste("ME",which.module, sep="")]
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ), nrgcols=30,rlabels=F,rcols=which.module, main=which.module, cex.main=2)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2, ylab="eigengene expression",xlab="sample")
```

# Diagnostics: displaying module heatmap and the eigengene
```{r, fig.width=7, fig.height=7}
which.module=gsub("ME","",names(merge$newMEs)[3]) #which.module="darkturquoise" #which.module="green"
ME=datME[, paste("ME",which.module, sep="")]
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ), nrgcols=30,rlabels=F,rcols=which.module, main=which.module, cex.main=2)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2, ylab="eigengene expression",xlab="sample")
```

# Diagnostics: displaying module heatmap and the eigengene
```{r, fig.width=7, fig.height=7}
which.module=gsub("ME","",names(merge$newMEs)[4]) #which.module="darkturquoise" #which.module="green"
ME=datME[, paste("ME",which.module, sep="")]
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ), nrgcols=30,rlabels=F,rcols=which.module, main=which.module, cex.main=2)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2, ylab="eigengene expression",xlab="sample")
```

# Diagnostics: displaying module heatmap and the eigengene
```{r, fig.width=7, fig.height=7}
which.module=gsub("ME","",names(merge$newMEs)[5]) #which.module="darkturquoise" #which.module="green"
ME=datME[, paste("ME",which.module, sep="")]
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ), nrgcols=30,rlabels=F,rcols=which.module, main=which.module, cex.main=2)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2, ylab="eigengene expression",xlab="sample")
```

# Finding modules that relate to a data trait

# Measure of module significance as average gene significance
```{r}
# The advantage of this second approach is that it can be used for any gene significance measure
# define a measure of module significance as the average gene significance of all genes in the module
# use the absolute value for defining a correlation based gene significance measure
GS = GeneSignificance = vector(mode = "list", length = length(tDados))
for (i in 1:length(tDados)){GS[[i]]=as.numeric(cor(tDados[[i]],datExpr, use="p"))}
for (i in 1:length(tDados)){GeneSignificance[[i]]=abs(GS[[i]])}
for (i in 1:length(GeneSignificance)){names(GeneSignificance[[i]]) = names(datExpr0)}

# Next module significance is defined as average gene significance.
ModuleSignificance = vector(mode = "list", length = length(tDados))
for (i in 1:length(tDados)){ModuleSignificance[[i]]=tapply(GeneSignificance[[i]], moduleColors, mean, na.rm=T)}
```

# To plot module significance
```{r, fig.width=7, fig.height=7}
plotModuleSignificance(GeneSignificance[[13]],moduleColors)
```

# The next logical step in an analysis of empirical data would be to carry out a functional enrichment analysis of each module

# Gene Set Enrichment Analysis
```{r, message=FALSE}
library("EnrichmentBrowser")
hibkegg.gs <- get.kegg.genesets("hiu")
#hibpwys <- download.kegg.pathways("hiu")
hib.grn <- compile.grn.from.kegg(hibpwys)



nbea.res <- nbea(method="ggea", eset=all.eset, gs=hibkegg.gs, grn=hib.grn)
```

# 
```{r}
MM.res=YpsPRP.res=YpsAc.res=YxpPRP.res=YxpAc.res=Yxs.res=MiPPRP.res=MiPAc.res=MiS.res=MiX.res=PpPRP.res=PpAc.res=Px.res=rsAc.res=rsPRP.res=rsG.res=rx.res=Massa.res = Acet.res = Glicose.res = PRP.res = CO2.res = O2.res = vector(mode = "list", length = ncol(datME))
for (j in 1:ncol(datME)){Massa.res[[j]] <- GeneSignificance[[1]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){Acet.res[[j]] <- GeneSignificance[[2]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){Glicose.res[[j]] <- GeneSignificance[[3]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){PRP.res[[j]] <- GeneSignificance[[4]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){CO2.res[[j]] <- GeneSignificance[[5]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){O2.res[[j]] <- GeneSignificance[[6]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){rx.res[[j]] <- GeneSignificance[[7]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){rsG.res[[j]] <- GeneSignificance[[8]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){rsPRP.res[[j]] <- GeneSignificance[[9]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){rsAc.res[[j]] <- GeneSignificance[[10]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){Px.res[[j]] <- GeneSignificance[[11]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){PpAc.res[[j]] <- GeneSignificance[[12]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){PpPRP.res[[j]] <- GeneSignificance[[13]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){MiX.res[[j]] <- GeneSignificance[[14]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){MiS.res[[j]] <- GeneSignificance[[15]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){MiPAc.res[[j]] <- GeneSignificance[[16]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){MiPPRP.res[[j]] <- GeneSignificance[[17]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){Yxs.res[[j]] <- GeneSignificance[[18]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){YxpAc.res[[j]] <- GeneSignificance[[19]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){YxpPRP.res[[j]] <- GeneSignificance[[20]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){YpsAc.res[[j]] <- GeneSignificance[[21]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){YpsPRP.res[[j]] <- GeneSignificance[[22]][rownames(moduleblocks[[j]])]}
for (j in 1:ncol(datME)){MM.res[[j]] <- GeneSignificance[[23]][rownames(moduleblocks[[j]])]}
```










```{r, message=FALSE}
library("gage")
kegg.gs = kegg.gsets(species = "hiu", id.type = "kegg")
WGCNA.res = vector(mode = "list", length = length(ModuleSignificance))
for (i in 1:length(ModuleSignificance)){WGCNA.res[[i]] = ModuleSignificance[[i]]}
```



# wgcna.kegg.p
```{r}
correl = MM.res

out.suffix="WGCNA"
#gage(WGCNAtpm, gsets = kegg.gs$kg.sets, same.dir = TRUE, ref = NULL, samp = NULL)

wgcna.kegg.p = vector(mode = "list", ncol(datME))
for (j in 1:ncol(datME)){wgcna.kegg.p[[j]] <- gage(correl[[j]], gsets = kegg.gs$kg.sets, same.dir = TRUE, ref = NULL, samp = NULL)}
```

```{r}
head(wgcna.kegg.p[[1]]$stats, 10)
```

```{r}
head(wgcna.kegg.p[[2]]$stats, 10)
```

```{r}
head(wgcna.kegg.p[[3]]$stats, 10)
```

```{r}
head(wgcna.kegg.p[[4]]$stats, 10)
```

```{r}
head(wgcna.kegg.p[[5]]$stats, 10)
```

# FDR q-value adjustment of the global p-value using the Benjamini & Hochberg procedure implemented in multtest package.
```{r}
sel = path.ids = sel.n = path.ids.n = path.idsn = vector(mode = "list", length = ncol(datME))
for (j in 1:ncol(datME)){sel[[j]] <- wgcna.kegg.p[[j]]$greater[, "q.val"] < 0.1 & !is.na(wgcna.kegg.p[[j]]$greater[, "q.val"])}
for (j in 1:ncol(datME)){path.ids[[j]] <- rownames(wgcna.kegg.p[[j]]$greater)[sel[[j]]]}
for (j in 1:ncol(datME)){sel.n[[j]] <- wgcna.kegg.p[[j]]$less[, "q.val"] < 0.1 & !is.na(wgcna.kegg.p[[j]]$less[,"q.val"])}
for (j in 1:ncol(datME)){path.ids.n[[j]] <- rownames(wgcna.kegg.p[[j]]$less)[sel.n[[j]]]}
for (j in 1:ncol(datME)){path.idsn[[j]] <- substr(c(path.ids[[j]], path.ids.n[[j]]), 1, 8)}
```

# pathview
```{r, message=FALSE}
require(pathview)
library("png")
pathviewplot = pathview(gene.data = correl[[1]], pathway.id = "hiu02010", species = "hiu", gene.idtype = "KEGG", out.suffix = out.suffix)
```

# Plot pathway
```{r}
library("png")
# read file
img <- readPNG("~/Dropbox/Mestrado/hiu02010.WGCNA.png")
# get size
h<-dim(img)[1]
w<-dim(img)[2]
# open new file for output
par(mar=c(0,0,0,0), xpd=NA, mgp=c(0,0,0), oma=c(0,0,0,0), ann=F)
plot.new()
plot.window(0:1, 0:1)
#fill plot with image
usr<-par("usr")    
rasterImage(img, usr[1], usr[3], usr[2], usr[4])
```


# Diagnostics: displaying module heatmap and the eigengene
```{r}
rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
```

# Diagnostics: displaying module heatmap and the eigengene
```{r}
rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
```

# Diagnostics: displaying module heatmap and the eigengene
```{r}
rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
```

# Diagnostics: displaying module heatmap and the eigengene
```{r}
rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
```
