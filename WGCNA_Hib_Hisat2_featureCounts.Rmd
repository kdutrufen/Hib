---
output:
  html_document: default
  pdf_document: default
---
y---
title: "WGCNA_from_Rsubread/Enrichment"
author: "Carlos Eduardo Madureira Trufen"
date: "7 de agosto de 2017"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set working directory
```{r}
setwd("~/Dropbox/Hib")
```

# Load packages
```{r}
library(tidyverse)
library(RColorBrewer)
library(ballgown)
library(WGCNA)
library(cluster)
library(RUVSeq)
library(EDASeq)
library(edgeR)
library(RUVSeq)
library(clusterProfiler)
library(data.table)
library(plyr)
library(plotrix)
source("~/Dropbox/kdutrufenr/kdutrufenr.R")
options(stringsAsFactors = FALSE)
```

```{r}
path_to_files <- "~/Dropbox/Hib_Data/"
```

# Protein list
```{r, message=FALSE}
Hib_proteins <- path_to_files %>% paste0("Haemophilus_influenzae_10810.GCF_000210875.1.proteintable.txt") %>% read_delim(delim = "\t", escape_double = FALSE, trim_ws = TRUE) %>% as.data.frame()
```

# Gene list
```{r, message=FALSE}
RefSeq_gff.genes <- path_to_files %>% paste0("GCF_000210875.1_ASM21087v1_genomic.gff") %>% gffRead() %>%
  filter(feature == "gene") %>%
  mutate(locustag = get_Attribute_Field(attributes, "Name", attrsep = ";")) %>%
  mutate(ID = get_Attribute_Field(attributes, "ID", attrsep = ";")) %>%
  mutate(OldLocusTag = get_Attribute_Field(attributes, "old_locus_tag", attrsep = ";")) %>%
  mutate(Gene_length = end - start) %>%
  full_join(Hib_proteins) %>%
  dplyr::select(Name = locustag, OldLocusTag, product)
```

# Read in Hib Matrix form Hisat alignment
```{r }
# Hib_CountData = read.csv("~/Dropbox/Hib_Data/Hib_Hisat2_featureCounts_table_countMultiMappingReads.txt", header=TRUE, sep = "\t", row.names = 1)
# Count matrix v1 (Hisat k -5, featureCounts -M)
# Hib_CountData <- read_delim("~/Dropbox/Hib_Data/Hib_Hisat2_featureCounts_table_countMultiMappingReads.txt", "\t", escape_double = FALSE, trim_ws = TRUE, skip = 1) %>% as.data.frame

# Count matrix v2 (Hisat k -2, featureCounts )
# Hib_CountData <- read_delim("~/Dropbox/Hib_Data/2_featureCounts_table_2018_09_14.txt", "\t", escape_double = FALSE, trim_ws = TRUE, skip = 1) %>% as.data.frame

# Count matrix v3 (Hisat k -5, featureCounts -M --primary)
Hib_CountData <- path_to_files %>% paste0("Hib_Hisat2_featureCounts_primary_table.txt") %>% read_delim(delim = "\t", escape_double = FALSE, trim_ws = TRUE, skip = 1) %>% as.data.frame()

# Remove rrf gene (ribosomal RNA)
# set Geneid as row names
# remove unwanted columns
# change column names
# countData = Hib_CountData %>% filter(!str_detect(Geneid, pattern = "rrf")) %>% column_to_rownames('Geneid') %>% select(-c(Chr, Start, End, Strand, Length)) %>% setNames(c("S01B01", "S01B02", "S01B03", "S01B04", "S02B01", "S02B02", "S02B03", "S02B04", "S03B01", "S03B02", "S03B03", "S03B04", "S04B01", "S04B02", "S04B03", "S04B04", "S05B01", "S05B02", "S05B03", "S05B04", "S06B01", "S06B02", "S06B03", "S06B04"))

Hib_CountData <- Hib_CountData %>%
  filter(!str_detect(Geneid, pattern = "rrf")) %>%
  column_to_rownames("Geneid") %>%
  dplyr::select(-c(Chr, Start, End, Strand, Length)) %>%
  setNames(sort(as.vector(outer(paste0("S0", 1:6), paste0("B0", 1:4), paste0))))

Hib_CountData$S03B02 <- NULL
```

# Rename row names to old locus tag
```{r }
# Rename Hib genes to old locus tag (available at KEGG)
# Sort row names alphabetically
# removeribosomal RNA
Hib_CountData <- Hib_CountData %>%
  rownames_to_column() %>%
  left_join(RefSeq_gff.genes, by = c("rowname" = "Name")) %>%
  mutate(Gene_names = if_else(is.na(OldLocusTag), rowname, OldLocusTag)) %>%
  arrange(Gene_names) %>%
  filter(!str_detect(Gene_names, pattern = "HIB_r")) %>%
  column_to_rownames(var = "Gene_names")
Hib_CountData$rowname <- Hib_CountData$OldLocusTag <- Hib_CountData$product <- NULL
```

# Sets design
```{r }
HibDesign <- data.frame(row.names = colnames(Hib_CountData), condition = str_sub(colnames(Hib_CountData), start = 1L, end = 3L))
```

# Unaligned
```{r }
# Hib_unaligned_CountData <- as.data.frame(read_delim("~/Dropbox/Hib_Data/unaligned_spades_salmon_counts_matrix.tsv", "\t", escape_double = FALSE, trim_ws = TRUE, skip = 0)) %>% column_to_rownames("transcript")
# 
# library(seqinr)
# Hib_unaligned_fasta = read.fasta("~/Dropbox/Hib_Data/Hib_genes_b2g_HI_Supragenome.fasta", as.string=TRUE)
# 
# Hib_unaligned_CountData = Hib_unaligned_CountData %>% rownames_to_column %>% filter(rowname %in% names(Hib_unaligned_fasta))
# 
# # Hib_unaligned_CountData = Hib_unaligned_CountData[rownames(Hib_unaligned_CountData) %in% names(Hib_unaligned_fasta),]
# 
# rownames(Hib_unaligned_CountData)[rownames(Hib_unaligned_CountData)=="NODE_15_length_7629_cov_3174.55_g0_i1"] = "H733_0475"
# 
# countData = rbind(Hib_CountData, Hib_unaligned_CountData)
```

# least significantly DE genes based on a first-pass DE analysis performed prior to RUVg normalization.
```{r, message=FALSE}
group <- HibDesign$condition %>% as.factor()
design <- model.matrix(~ 0 + group)
colnames(design) <- levels(group)
rownames(design) <- colnames(Hib_CountData)

# group=as.factor(HibDesign1$condition)
# design <- model.matrix(~0 + group)
# colnames(design) <- levels(group)
# rownames(design) = colnames(countData)

countData <- Hib_CountData

# myCPM = cpm(d)
# cpm(1, mean(d$samples$lib.size))
# CPMthershold = round(cpm(1, mean(d$samples$lib.size)), digits=2)
# keep <- rowSums(cpm(d)> as.vector(CPMthershold)) >= 4
# filtered <- d[keep,]
# summary(keep)
# dim(filtered )

d <- countData %>% DGEList(lib.size = colSums(countData), group = group)
keep <- rowSums(d %>% cpm() > 1) >= 1
filtered <- d[keep, ]
keep %>% summary()
filtered %>% dim()

filtered_countData <- filtered$counts

fit <- filtered_countData %>%
  DGEList(lib.size = colSums(filtered_countData), group = group) %>%
  calcNormFactors(method = "TMM") %>%
  estimateDisp(design = design, tagwise = TRUE, robust = TRUE) %>%
  glmFit(design)
lrt <- fit %>% glmLRT(coef = 2:6)
top <- topTags(lrt, n = nrow(d))$table
empirical <- rownames(filtered_countData)[which(!(rownames(filtered_countData) %in% rownames(top)[1:500]))]
```

# Here, we consider all but the top 500 genes as ranked by edgeR p-values
```{r }
# The RUVg function  returns  two  pieces  of  information:
# the estimated factors of unwanted variation nd the normalized counts obtained by regressing the original counts on the unwanted factors
# The normalized values are stored in the normalizedCounts slot
set2 <- fit$counts %>% as.matrix %>% RUVg(empirical, k=1)
```

# plotRLE creates relative log expression (RLE) plot, initially proposed to measure the overall quality of a dataset 
# plotRLE can also be used to visualize the presence of unwanted batch effects in the data
```{r}
# col.cell <- c("purple", "orange", "blue", "red", "green", "black", "cyan", "darkgoldenrod", "darkorchid", "darkslategray")[as.factor(HibDesign$condition)]
col.cell <- brewer.pal(6, "Set3")[as.factor(HibDesign$condition)]
# plotRLE creates relative log expression (RLE) plot, initially proposed to measure the overall quality of a dataset
# plotRLE can also be used to visualize the presence of unwanted batch effects in the data
par(mfrow = c(1, 2), mar = c(8.1, 4.1, 4.1, 2.1))
filtered$counts %>% as.matrix() %>% plotRLE(outline = FALSE, ylim = c(-4, 4), col = col.cell, main = "Samples with \n unwanted variation", las = 2, cex.axis = 0.8, style = "full", outlier.alpha = 0.1, outlier.shape = 3, outlier.size = 0, legend = TRUE)
legend("topright", legend = levels(group), col = unique(col.cell), ncol = 2, cex = 0.7, border = "black", fill = unique(col.cell))
mtext(side = 1, text = "Samples", line = 7)
mtext(side = 2, text = "Relative Log Expression (RLE)", line = 1.5)

set2$normalizedCounts %>% plotRLE(outline = FALSE, ylim = c(-4, 4), col = col.cell, main = "Samples without \n unwanted variation", las = 2, cex.axis = 0.8, style = "full", outlier.alpha = 0.1, outlier.shape = 3, outlier.size = 0)
legend("topright", legend = levels(group), col = unique(col.cell), ncol = 2, cex = 0.7, border = "black", fill = unique(col.cell))
mtext(side = 1, text = "Samples", line = 7)
mtext(side = 2, text = "Relative Log Expression (RLE)", line = 1.5)
```

# Set design, removing batch effect
```{r}
# HibDesign2 = data.frame(row.names = colnames( countData ), condition = rep(c("S01", "S02", "S03", "S04", "S05", "S06"), each = 4),  set2$W)
# design = model.matrix(~group+set2$W, data = HibDesign2)
# colnames(design) <- c(levels(group), "W")
# group=as.factor(HibDesign2[,1])
```

#Pre-processing
```{r}
# We do not recommend filtering genes by differential expression. WGCNA is designed to be an unsupervised analysis method that clusters genes based on their expression profiles. Filtering genes by differential expression will lead to a set of correlated genes that will essentially form a single (or a few highly correlated) modules. It also completely invalidates the scale-free topology assumption, so choosing soft thresholding power by scale-free topology fit will fail. 
```

# TMM normaliztion from edgeR
```{r}
WGCNAtpm <- set2$normalizedCounts %>%
  DGEList(lib.size = set2$normalizedCounts %>% colSums(), group = group) %>%
  calcNormFactors("TMM") %>%
  cpm(normalized.lib.sizes = TRUE) %>%
  as.data.frame()

WGCNAtpm %>% head()
```

# plotRLE
```{r, fig.height = 5, fig.width = 15}
# col.cell <- c("purple","orange", "blue", "red", "green", "black")[as.factor(HibDesign[,1])]
col.cell <- brewer.pal(6, "Set3") %>% .[HibDesign$condition %>% as.factor]

par(mfrow=c(1,3), mar = c(8.1, 4.1, 4.1, 2.1))
filtered$counts %>% as.matrix() %>% plotRLE(outline = FALSE, ylim = c(-4, 4), col = col.cell, main = "Samples with \n unwanted variation", las = 2, cex.axis = 0.8, style = "full", outlier.alpha = 0.1, outlier.shape = 3, outlier.size = 0, legend = TRUE)
legend("topright", legend = levels(group), col = unique(col.cell), ncol = 2, cex = 0.7, border = "black", fill = unique(col.cell))
mtext(side = 1, text = "Samples", line = 7)
mtext(side = 2, text = "Relative Log Expression (RLE)", line = 1.5)

set2$normalizedCounts %>% plotRLE(outline = FALSE, ylim = c(-4, 4), col = col.cell, main = "Samples without \n unwanted variation", las = 2, cex.axis = 0.8, style = "full", outlier.alpha = 0.1, outlier.shape = 3, outlier.size = 0)
legend("topright", legend = levels(group), col = unique(col.cell), ncol = 2, cex = 0.7, border = "black", fill = unique(col.cell))
mtext(side = 1, text = "Samples", line = 7)
mtext(side = 2, text = "Relative Log Expression (RLE)", line = 1.5)

WGCNAtpm %>% as.matrix() %>% plotRLE(outline = FALSE, ylim = c(-4, 4), col = col.cell, main = "Samples without \n unwanted variation \n and normalized with TPM", las = 2, cex.axis = 0.8, style = "full", outlier.alpha = 0.1, outlier.shape = 3, outlier.size = 0, legend = TRUE)
legend("topright", legend = levels(group), col = unique(col.cell), ncol = 2, cex = 0.7, border = "black", fill = unique(col.cell))
mtext(side = 1, text = "Samples", line = 7)
mtext(side = 2, text = "Relative Log Expression (RLE)", line = 1.5)
```


# Transpose the expression data for further analysis
# Henceforth, each row will correspond to a sample and each column to a gene
```{r}
datExpr0 <- WGCNAtpm %>% t() %>% as.data.frame() %>% scale()
```

# Transpose the expression data for further analysis
# Henceforth, each row will correspond to a sample and each column to a gene
```{r}
#blockwiseModules(datExpr0)
```


# cluster the samples to see if there are any obvious outliers.
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
```{r}
sampleTree <- datExpr0 %>% dist() %>% hclust(method = "average")
plot(sampleTree, main = "", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2, ylab = "altura")
abline(h = 1, col = "red") # Plot a line to show the cut
```

```{r}
library(factoextra)

color <- grDevices::colors()[grep("gr(a|e)y", grDevices::colors(), invert = T)]

sampleTree <- hclust(dist(datExpr0), method = "average")

# fviz_dend(sampleTree, cex = 0.5)

fviz_dend(sampleTree,
  k = 6, # Cut in four groups
  cex = 0.5, # label size
  k_colors = c("purple", "orange", "blue", "red", "green", "black"),
  color_labels_by_k = TRUE, # color labels by groups
  rect = TRUE # Add rectangle around groups
)
# abline(h = 1, col = "red") # Plot a line to show the cut
```

# Determine cluster under the line
```{r}
clust <- cutreeStatic(sampleTree, cutHeight = 2500000, minSize = 10)
table(clust)
```

# clust contains the samples we want to keep.
```{r}
keepSamples <- (clust == 1)
datExpr <- datExpr0[keepSamples, ]
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
```

# To compare samples 2 by 2, 3 by 3..
```{r}
# nSets = 14
# multiExpr = vector(mode = "list", length = nSets)
# g = function(j) {if (j==0){result = 0}
#   else {result = sum(5-(1:j-1))}
#   return(result)}
# for (j in 0:3){for (i in 1:(5-j)){multiExpr[[i+g(j)]] = list(data = datExpr[(4*i-3):(4*i+4*j+4),])}}

```

# Constructing a weighted gene network entails the choice of the soft thresholding power to which co-expression similarity is raised to calculate adjacency
```{r}
# The choice for soft thresholding power is based on the criterion of approximate scale-free topology.
#Choose a set of soft-thresholding powers
powers = c(c(2:10), seq(from = 12, to=30, by=2))
```

# Call the network topology analysis function
```{r}
# Let p(dk) be the frequency distribution 
# scale-free topology fitting index measures the extent of a straight line relationship between log(p(r)) and log(r)
# scale-free topology fitting index is defined as the square of the correlation coefficient between log(p(dk)) and log(BinNo)
# Networks whose scale-free topology index R2 is close to 1 are defined to be approximately scale free.
# connectivity distribution p(r) may be better moduled using an Exponentially truncated power law: p(r) = PositiveNumber*r^(-?)*exp(-ar); ? and a positive real numbers 
sft <- datExpr %>% pickSoftThreshold(powerVector = powers, verbose = 2, moreNetworkConcepts = TRUE)
softPower <- sft$fitIndices %>% filter(SFT.R.sq > 0.8) %>% dplyr::select(Power) %>% pull() %>% min()

# softPower = sft$fitIndices[min(which(sft$fitIndices[,2]>0.8)),1]
if (is.na(softPower)) {  softPower <- 10 }
```


# Plot the results:
```{r, fig.width=10, fig.height=5}
op <- par(no.readonly = TRUE)
par(mar = c(6, 6, 3, 3), cex.axis = 1.5, cex.lab = 1.5)
par(mfrow = c(1, 2))
cex1 <- 0.9

# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices$Power, -sign(sft$fitIndices$slope) * sft$fitIndices$SFT.R.sq, xlab = "Soft Threshold (power)", ylab = "Scale Free Topology Model Fit", type = "n", main = paste("Scale independence"))
axis(side = 2, at = c(0.0, 0.2, 0.4, 0.6, 0.8), labels = format(c(0.0, 0.2, 0.4, 0.6, 0.8), decimal.mark = "."))
text(sft$fitIndices$Power, -sign(sft$fitIndices$slope) * sft$fitIndices$SFT.R.sq, labels = powers, cex = cex1, col = "red")
# this line corresponds to using an R^2 cut-off of h
abline(h = 0.80, col = "red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices$Power, sft$fitIndices$mean.k., xlab = "Soft Threshold (power)", ylab = "Mean Connectivity", type = "n", main = paste("Mean Connectivity"))
text(sft$fitIndices$Power, sft$fitIndices$mean.k., labels = powers, cex = cex1, col = "red")
```


```{r}
datExpr <- datExpr %>% apply(MARGIN = c(1, 2), FUN = as.numeric)
```

# Co-expression similarity and adjacency
```{r}
# The relationship between R2 and the threshold parameter (t or ? ) follows approximately a saturation curve
# The refined scale-free topology criterion: 
# use the first threshold parameter value where saturation is reached as long as it is above 0.8
# We now calculate the adjacencies, using the soft thresholding power 
# n?n dimensional adjacency matrix A = (Aij), where the entry Aij quantifies the connection strength from node i to node j
# For a weighted network, Aij takes on a real number between 0 and 1
# The power adjacency function changes the topological properties (network concepts) of weighted networks
adjacency <- datExpr %>% adjacency(power = softPower)
```

# Evaluate the scale free topology fit of the network
```{r, message=FALSE}
# The function scaleFreePlot() plots a log-log plot of a histogram of the given connectivities, and fits a linear model plus optionally a truncated exponential model
# The R2 of the fit can be considered an index of the scale freedom of the network topology
#sizeGrWindow(10,5)
#hist(adjacency)
#scaleFreePlot(adjacency , truncated = TRUE, main="Topologia sem escala\n")
adjacency %>% scaleFreePlot(truncated = TRUE, cex.lab = 1.2, cex.axis = 1.5)
```

# Topological Overlap Matrix (TOM)
```{r, message=FALSE}
# To minimize effects of noise and spurious associations, we transform the adjacency into Topological Overlap Matrix, and calculate the corresponding dissimilarity
# We will use the topological overlap measure as robust measure of interconnectedness
# The function TOMsimilarity() takes as input a weighted (or possibly unweighted) adjacency matrix and outputs the first order (m=1) GTOMmeasure
# This function cannot calculate higher order (m > 1) generalizations of the TOM measure
# Turn adjacency into topological overlap
TOM <- adjacency %>% TOMsimilarity()
dissTOM <- 1 - TOM
```



# Clustering using TOM
```{r}
# use the TOM-based dissimilarity as input of average linkage hierarchical clustering
# which results in a cluster tree (dendrogram) of the network
# Call the hierarchical clustering function hclust() to produce a hierarchical clustering tree (dendrogram) of genes
geneTree <- dissTOM %>% as.dist() %>% hclust(method = "average")
```

# Plot the resulting clusteringarallel tree (dendrogram)
```{r, fig.width=7, fig.height=7}
# In the clustering tree (dendrogram), each leaf, that is a short vertical line, corresponds to a gene.
# Gene modules are defined as branches of the hierarchical clustering tree (dendrogram)
# Branches of the dendrogram group together densely interconnected, highly co-expressed genes.
geneTree %>% plot(xlab = "", sub = "", main = "Gene clustering on TOM-based dissimilarity", labels = FALSE, hang = 0.04)
```

# Minimum Module Size
```{r}
# dynamicModstest_list <- map(1:100, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = i) %>% max()) %>% unlist()
# dynamicModstest_df <- data.frame(minimum_n_genes = 1:100, n_modules = dynamicModstest)
# dynamicModstest_df %>% ggplot(aes(x = minimum_n_genes, y = n_modules)) + geom_line() + geom_point() + theme_bw()
# 
# estimate_elbow <- function(n_genes = n_genes, TOM = TOM, deepSplit = deepSplit, gene_names = gene_names) {
#   dissTOM = 1 - TOM
#   dynamicModstest_list <- map(n_genes, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = deepSplit, pamRespectsDendro = FALSE, minClusterSize = i))
#   dynamicModstest <- map(seq_along(dynamicModstest_list), function(i) dynamicModstest_list[[i]] %>% max()) %>% unlist()
#   dynamicColorstest <- map(seq_along(dynamicModstest_list), function(i) dynamicModstest_list[[i]] %>% labels2colors())
#   dynamicColorstest1 <- map(seq_along(dynamicModstest_list), function(i) data.frame(dynamicColors = dynamicColorstest[[i]], genes = gene_names))
#   premoduleblockstest <- map(seq_along(dynamicColorstest1), function(i) dynamicColorstest1[[i]] %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull))
#   gene_names <- gene_names
#   inModuletest <- map(seq_along(premoduleblockstest), function(i) map(seq_along(premoduleblockstest[[i]]), function(j) gene_names %in% premoduleblockstest[[i]][[j]]))
#   # Select the corresponding Topological Overlap
#   modTOMtest <- map(seq_along(inModuletest), function(i) map(seq_along(inModuletest[[i]]), function(j) TOM[inModuletest[[i]][[j]], inModuletest[[i]][[j]]]))
#   for (i in 1:length(modTOMtest)) {
#     for (j in 1:length(modTOMtest[[i]])) {
#       dimnames(modTOMtest[[i]][[j]]) <- list(premoduleblockstest[[i]][[j]], premoduleblockstest[[i]][[j]])
#     }
#   }
#   ssd <- function(x) sum((x - mean(x))^2)
#   SSD <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd())) %>% map(unlist) %>% map(sum) %>% unlist()
#   dynamicModstest_df <- data.frame(minimum_n_genes = n_genes, n_modules = dynamicModstest, SSD = SSD)
#   gg_plot <- dynamicModstest_df %>% ggplot(aes(x = n_modules, y = SSD)) + geom_line() + geom_point() + theme_bw()
#   results <- list()
#   results[["plot"]] <- gg_plot
#   results[["table"]] <- dynamicModstest_df
#   return(results)
# }
# 
# estimated <- estimate_elbow(n_genes = 1:100, dissTOM = dissTOM, deepSplit = 4, gene_names = datExpr %>% colnames())
# 
# 
# parallel_estimate_elbow <- function(n_genes = n_genes, TOM = TOM, deepSplit = deepSplit, gene_names = gene_names, no_cores = detectCores() - 1) {
#   library(parallelMap)
#   # Initiate cluster
#   parallelStartSocket(no_cores)
#   dissTOM = 1 - TOM
#   dynamicModstest_list <- map(n_genes, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = deepSplit, pamRespectsDendro = FALSE, minClusterSize = i))
#   dynamicModstest <- map(seq_along(dynamicModstest_list), function(i) dynamicModstest_list[[i]] %>% max()) %>% unlist()
#   dynamicColorstest <- map(seq_along(dynamicModstest_list), function(i) dynamicModstest_list[[i]] %>% labels2colors())
#   dynamicColorstest1 <- map(seq_along(dynamicModstest_list), function(i) data.frame(dynamicColors = dynamicColorstest[[i]], genes = gene_names))
#   premoduleblockstest <- map(seq_along(dynamicColorstest1), function(i) dynamicColorstest1[[i]] %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull))
#   gene_names <- gene_names
#   inModuletest <- map(seq_along(premoduleblockstest), function(i) map(seq_along(premoduleblockstest[[i]]), function(j) gene_names %in% premoduleblockstest[[i]][[j]]))
#   # Select the corresponding Topological Overlap
#   modTOMtest <- map(seq_along(inModuletest), function(i) map(seq_along(inModuletest[[i]]), function(j) TOM[inModuletest[[i]][[j]], inModuletest[[i]][[j]]]))
#   for (i in 1:length(modTOMtest)) {
#     for (j in 1:length(modTOMtest[[i]])) {
#       dimnames(modTOMtest[[i]][[j]]) <- list(premoduleblockstest[[i]][[j]], premoduleblockstest[[i]][[j]])
#     }
#   }
#   ssd <- function(x) sum((x - mean(x))^2)
#   SSD <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd())) %>% map(unlist) %>% map(sum) %>% unlist()
#   dynamicModstest_df <- data.frame(minimum_n_genes = n_genes, n_modules = dynamicModstest, SSD = SSD)
#   gg_plot <- dynamicModstest_df %>% ggplot(aes(x = n_modules, y = SSD)) + geom_line() + geom_point() + theme_bw()
#   parallelStop()
#   results <- list()
#   results[["plot"]] <- gg_plot
#   results[["table"]] <- dynamicModstest_df
#   return(results)
# }
# 
# estimated_parallel <- parallel_estimate_elbow(n_genes = 1:100, TOM = TOM, deepSplit = 4, gene_names = datExpr %>% colnames())
# 
# estimated_parallel$data <- estimated_parallel$data %>% mutate(SSD = SSD %>% round(digits = 2))
# 
# estimated_parallel$data %>% write.table(file = "~/Dropbox/Hib_Data/Hib_WGCNA_elbow_method_like.tsv", sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE )
#   
# # estimated_comparison = microbenchmark::microbenchmark(
# #   estimated <- estimate_elbow(n_genes = 1:100, dissTOM = dissTOM, deepSplit = 4, gene_names = datExpr %>% colnames()),
# #   estimated_parallel = parallel_estimate_elbow(n_genes = 1:100, dissTOM = dissTOM, deepSplit = 4, gene_names = datExpr %>% colnames()),
# #   times = 20
# # )
# 
# library(parallel)
# library(parallelMap)
# # from https://mlr.mlr-org.com/articles/tutorial/parallelization.html
# parallel_bmr <- function(lrns, task_train, rdesc, meas) {
#   # Calculate the number of cores
#   no_cores <- detectCores() - 1
#   # Initiate cluster
#   parallelStartSocket(no_cores)
#   set.seed(666)
#   bmr <- benchmark(lrns, task_train, rdesc, meas, show.info = FALSE)
#   parallelStop()
#   bmr
# }
# 
# dynamicModstest_list <- map(1:100, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = i) )
# 
# # dynamicModstest <- geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = 10)
# map(seq_along(dynamicModstest_list) , function(i) dynamicModstest_list[[i]] %>% table())
# dynamicColorstest <- map(seq_along(dynamicModstest_list) , function(i) dynamicModstest_list[[i]] %>% labels2colors())
# 
# dynamicColorstest1 <- map(seq_along(dynamicModstest_list) , function(i) data.frame(dynamicColors = dynamicColorstest[[i]], genes = rownames(adjacency)) )
# 
# premoduleblockstest <- map(seq_along(dynamicColorstest1) , function(i) dynamicColorstest1[[i]] %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull) )
# 
# gene_names <- datExpr %>% colnames()
# inModuletest <- map(seq_along(premoduleblockstest), function(i) map(seq_along(premoduleblockstest[[i]]), function(j) gene_names %in% premoduleblockstest[[i]][[j]] ) )
# 
# # Select the corresponding Topological Overlap
# modTOMtest <- map(seq_along(inModuletest), function(i) map(seq_along(inModuletest[[i]]), function(j) TOM[inModuletest[[i]][[j]], inModuletest[[i]][[j]]]))
# 
# # map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) dimnames(modTOMtest[[i]][[j]]) <- list(premoduleblockstest[[i]][[j]], premoduleblockstest[[i]][[j]]) ))
# 
# for (i in 1:length(modTOMtest)) { for (j in 1:length(modTOMtest[[i]])) {dimnames(modTOMtest[[i]][[j]]) <- list(premoduleblockstest[[i]][[j]], premoduleblockstest[[i]][[j]]) } }
# 
# # Function to calculate the sum of squared deviations (from the mean)
# # ssd <- function(x) var(x)*(length(x)-1)
# ssd <- function(x) sum((x-mean(x))^2)
# 
# # SSD <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd() %>% sum())) %>% map(unlist) %>% map(sum) %>% unlist()
# 
# SSD <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd())) %>% map(unlist) %>% map(sum) %>% unlist()
# 
# # library(microbenchmark)
# # test <- microbenchmark(
# #   SSD <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd() %>% sum())) %>% map(unlist) %>% map(sum) %>% unlist(),
# #   SSD_1 <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd_1() %>% sum())) %>% map(unlist) %>% map(sum) %>% unlist(),
# #   times = 20
# # )
# 
# # x<-c(16, 17, 18, 20, 16, 20, 20, 18, 18, 15, 16, 16, 19, 17, 19)
# # test_1 <- microbenchmark(
# #   SSD <- x %>% ssd,
# #   SSD_1 <- x %>% ssd_1,
# #   times = 1000
# # )
# 
# 
# dynamicModstest_df <- data.frame(minimum_n_genes = 1:100, 
#                                  n_modules = dynamicModstest,
#                                  SSD = SSD)
# 
# library(plotly)
# p <- dynamicModstest_df %>% plot_ly(x = ~minimum_n_genes, y = ~n_modules, z = ~SSD, type = 'scatter3d', mode = 'lines', opacity = 1, line = list(width = 6, color = ~color, reverscale = FALSE))
# # chart_link = p %>% api_create(filename="line3d-basic")
# # chart_link
# 
# dynamicModstest_df %>% ggplot(aes(x = n_modules, y = SSD)) + geom_line() + geom_point() + theme_bw()
# # dynamicModstest_df %>% write.table(file = paste0("~/Dropbox/Hib_Data/Hib_WGCNA_elbow_method_like.tsv" ), sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE )
# 
# dynamicModstest_df %>% ggplot(aes(x = minimum_n_genes, y = n_modules)) + geom_line() + geom_point() + theme_bw()
# 
# # dynamicModstest_1 <- vector()
# # for (i in 1:100) {dynamicModstest_1[i] <- geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = i) %>% max}
# 
# # forxmap_test <- microbenchmark::microbenchmark(
# #   lapply_dynamicModstest = lapply(5:6, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = i) %>% max),
# #   map_dynamicModstest = map(5:6, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = i) %>% max),
# #   for_dynamicModstest = for (i in 5:6) { geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = i) %>% max },
# #   times = 100
# # )
# # 
# # qplot(y=time, data=forxmap_test, colour=expr) + scale_y_log10()
```


# function parallel_estimate_elbow
```{r}
# n_genes = 1:100
# TOM = TOM
# deepSplit = 4
# gene_names = datExpr %>% colnames()
# no_cores = detectCores() - 1
# 
# parallel_estimate_elbow <- function(n_genes = n_genes, TOM = TOM, deepSplit = deepSplit, gene_names = gene_names, no_cores = detectCores() - 1) {
#   library(parallelMap)
#   # Initiate cluster
#   parallelStartSocket(no_cores)
#   # estimate geneTree
#   geneTree <- dissTOM %>% as.dist() %>% hclust(method = "average")
#   # dissTOM
#   dissTOM = 1 - TOM
#   dynamicModstest_list <- map(n_genes, function(i) geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = deepSplit, pamRespectsDendro = FALSE, minClusterSize = i))
#   
#   dynamicModstest <- map(seq_along(dynamicModstest_list), function(i) dynamicModstest_list[[i]] %>% max()) %>% unlist()
#   dynamicColorstest <- map(seq_along(dynamicModstest_list), function(i) dynamicModstest_list[[i]] %>% labels2colors())
#   dynamicColorstest1 <- map(seq_along(dynamicModstest_list), function(i) data.frame(dynamicColors = dynamicColorstest[[i]], genes = gene_names))
#   premoduleblockstest <- map(seq_along(dynamicColorstest1), function(i) dynamicColorstest1[[i]] %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull))
#   gene_names <- gene_names
#   inModuletest <- map(seq_along(premoduleblockstest), function(i) map(seq_along(premoduleblockstest[[i]]), function(j) gene_names %in% premoduleblockstest[[i]][[j]]))
#   # Select the corresponding Topological Overlap
#   modTOMtest <- map(seq_along(inModuletest), function(i) map(seq_along(inModuletest[[i]]), function(j) TOM[inModuletest[[i]][[j]], inModuletest[[i]][[j]]]))
#   for (i in 1:length(modTOMtest)) {
#     for (j in 1:length(modTOMtest[[i]])) {
#       dimnames(modTOMtest[[i]][[j]]) <- list(premoduleblockstest[[i]][[j]], premoduleblockstest[[i]][[j]])
#     }
#   }
#   ssd <- function(x) sum((x - mean(x))^2)
#   SSD <- map(seq_along(modTOMtest), function(i) map(seq_along(modTOMtest[[i]]), function(j) modTOMtest[[i]][[j]] %>% ssd())) %>% map(unlist) %>% map(sum) %>% unlist()
#   dynamicModstest_df <- data.frame(minimum_n_genes = n_genes, n_modules = dynamicModstest, SSD = SSD)
#   gg_plot <- dynamicModstest_df %>% ggplot(aes(x = n_modules, y = SSD)) + geom_line() + geom_point() + theme_bw()
#   parallelStop()
#   results <- list(plot = gg_plot, 
#                   table = dynamicModstest_df)
#   # results[["plot"]] <- gg_plot
#   # results[["table"]] <- dynamicModstest_df
#   return(results)
# }
```

```{r}
# estimated_parallel <- parallel_estimate_elbow(n_genes = 1:100, TOM = TOM, deepSplit = 4, gene_names = datExpr %>% colnames())
```

```{r}
# library(factoextra)
# library(NbClust)
# 
# NbClust_results <- NbClust(data = WGCNAtpm, diss = dissTOM, distance = NULL, method = "average", max.nc = 500, index = "all")
# 
# fviz_nbclust_results <- dissTOM %>% fviz_nbclust(FUNcluster = kmeans, method = "wss", k.max = 100)
# fviz_nbclust_results <- dissTOM %>% fviz_nbclust(FUNcluster = kmeans, method = "silhouette")
# fviz_nbclust_results <- dissTOM %>% fviz_nbclust(FUNcluster = kmeans, method = "gap_stat")
```

```{r}
minModuleSize <- 15
```

# Module identification using dynamic tree cut:
```{r}
dynamicMods <- geneTree %>% cutreeDynamic(distM = dissTOM, deepSplit = 4, pamRespectsDendro = FALSE, minClusterSize = minModuleSize)
dynamicMods %>% table()
```

# Convert numeric lables into colors
```{r}
dynamicColors <- dynamicMods %>% labels2colors()
```

# Genes of proper modules (branches) are assigned a color
# Genes outside any proper module are colored gray
```{r}
dynamicColors %>% table()
```

# Genes in modules
```{r, message=FALSE}
dynamicColors1 = data.frame(dynamicColors = dynamicColors, genes = rownames(adjacency))
premoduleblocks <- dynamicColors1 %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull)
```

# Plot the dendrogram and colors underneath
```{r, fig.width=7, fig.height=7}
geneTree %>% plotDendroAndColors(dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors")
```

# Merging of modules whose expression profiles are very similar
```{r}
# Calculate eigengenes
MEList <- datExpr %>% moduleEigengenes(colors = dynamicColors)
MEs <- MEList$eigengenes
```

# Calculate dissimilarity of module eigengenes
```{r}
MEDiss <- 1 - cor(MEs)
```

# Cluster module eigengenes
```{r}
METree <- MEDiss %>% as.dist() %>% hclust(method = "average")
```

# Plot the result
```{r, fig.width=7, fig.height=7}
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
```

# We choose a height cut of 0.25 to merge, corresponding to correlation of 0.75.
```{r}
# # mergetest <- map(seq(from = 0.05, to = 0.50, by = 0.01), function(i) datExpr %>% mergeCloseModules(colors = dynamicColors, cutHeight = i, verbose = 3) %>% .[["colors"]] %>% table() %>% length()) %>% unlist()
# estimated_cut <- estimate_threshold_cut(thresh_cut = seq(from = 0.01, to = 1.0, by = 0.01), datExpr = datExpr, dynamicColors = dynamicColors, gene_names = datExpr %>% colnames(), TOM = TOM)
# estimated_cut %>% plot
# 
# mergetest_list <- map(seq(from = 0.05, to = 0.50, by = 0.01), function(i) datExpr %>% mergeCloseModules(colors = dynamicColors, cutHeight = i, verbose = 3) %>% .[["colors"]])
# 
# mergetest <- mergetest_list %>% map(table) %>% map(length) %>% unlist
# 
# mergetest_1 <- map(seq_along(mergetest_list) , function(i) data.frame(dynamicColors = mergetest_list[[i]], genes = rownames(adjacency)) )
# 
# merge_blockstest <- map(seq_along(mergetest_1), function(i) mergetest_1[[i]] %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull))
# 
# gene_names <- datExpr %>% colnames()
# inModule_merge_test <- map(seq_along(merge_blockstest), function(i) map(seq_along(merge_blockstest[[i]]), function(j) gene_names %in% merge_blockstest[[i]][[j]] ) )
# 
# # Select the corresponding Topological Overlap
# modTOM_merge_test <- map(seq_along(inModule_merge_test), function(i) map(seq_along(inModule_merge_test[[i]]), function(j) TOM[inModule_merge_test[[i]][[j]], inModule_merge_test[[i]][[j]]]))
# 
# for (i in 1:length(modTOM_merge_test)) { for (j in 1:length(modTOM_merge_test[[i]])) {dimnames(modTOM_merge_test[[i]][[j]]) <- list(merge_blockstest[[i]][[j]], merge_blockstest[[i]][[j]]) } }
# 
# # Function to calculate the sum of squared deviations (from the mean)
# ssd <- function(x) sum((x-mean(x))^2)
# 
# SSD_merge <- map(seq_along(modTOM_merge_test), function(i) map(seq_along(modTOM_merge_test[[i]]), function(j) modTOM_merge_test[[i]][[j]] %>% ssd())) %>% map(unlist) %>% map(sum) %>% unlist()
# 
# 
# mergetest_df <- data.frame(cor_thres = seq(from = 0.05, to=0.50, by=0.01), 
#                            n_modules = mergetest,
#                            SSD_merge = SSD_merge)
# 
# mergetest_df %>% ggplot(aes(x = n_modules, y = SSD_merge)) + geom_line() + geom_point() + theme_bw()
# 
# mergetest_df %>% ggplot(aes(x = cor_thres, y = SSD_merge)) + geom_line() + geom_point() + theme_bw()
# 
# ploty_line <- mergetest_df %>% plot_ly(x = ~cor_thres, y = ~n_modules, z = ~SSD_merge, type = 'scatter3d', mode = 'lines', opacity = 1, line = list(width = 6, color = ~color, reverscale = FALSE))
# 
# Sys.setenv("plotly_username" = "kdutrufen")
# api_create(ploty_line, filename = "ploty_line")
# 
# 
# chart_link = api_create(ploty_line, filename="line3d-color")
# 
# 
# 
# MEDissThres <- 0.22
```

# Plot the cut line into the dendrogram
```{r, fig.width=7, fig.height=7}
plot(METree, main = "Clusterização de autogenes dos módulos", ylab = "Altura", xlab = "", sub = "", cex.lab = 1.5, cex.main = 1.5)
MEDissThres <- 0.25
axis(side = 2, at = c(0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2), labels = format(c(0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2), decimal.mark = ","))
abline(h = MEDissThres, col = "red")
```

# Call an automatic merging function
```{r}
merge <- datExpr %>% mergeCloseModules(dynamicColors, cutHeight = MEDissThres, verbose = 3)
```

```{r}
merge$newMEs
```

# The merged module colors
```{r}
mergedColors <- merge$colors
```

# Eigengenes of the new merged modules:
```{r}
mergedMEs <- merge$newMEs
```

# plot the gene dendrogram again, with the original and merged module colors underneath
```{r, fig.width=7, fig.height=7}
geneTree %>% plotDendroAndColors(cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), ylab = "Altura", dendroLabels = FALSE, cex.lab=1.5, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
#axis(side=2, at = c(0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0), labels = format(c(0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0), decimal.mark=","))
```

# In the subsequent analysis, we will use the merged module colors in mergedColors.
```{r}
## We save the relevant variables for use in subsequent steps
# Rename to moduleColors
moduleColors <- mergedColors
moduleColors %>% table() %>% as.data.frame  %>% write.table(file = "~/Dropbox/Hib_Data/Hib_WGCNA_Modulesxn_Genes.tsv", sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE )
```

# Construct numerical labels corresponding to the colors
```{r}
colorOrder <- c("grey", standardColors(50))
moduleLabels <- match(moduleColors, colorOrder) - 1
MEs <- mergedMEs
```

# Genes in each module
```{r}
dynamicColors2 <- data.frame(dynamicColors = moduleColors, genes = rownames(adjacency))
moduleblocks <- dynamicColors2 %>% split(f = .$dynamicColors) %>% map(dplyr::select, -dynamicColors) %>% map(pull)
```

# Plot the dendrogram and colors underneath
```{r, fig.width=7, fig.height=7}
geneTree %>% plotDendroAndColors(dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Dendograma dos genes e cores dos m?dulos", ylab="Altura", cex.main = 1.5, cex.lab = 1.5)
```



# Standard gene screening based on marginal correlation
# Relating modules and module eigengenes to external data
```{r}
# how related the modules are
datME <- datExpr %>% moduleEigengenes(moduleColors) %>% .[["eigengenes"]]
datME %>% cor(use = "p") %>% signif(digits = 2)
```

# We define a dissimilarity measure between the module eigengenes  that keeps track of the sign of the correlation between the module eigengenes, and use it to cluster the eigengene
```{r, fig.width=7, fig.height=7}
dissimME <- (1 - t(cor(datME, method = "p"))) / 2
hclustdatME <- dissimME %>% as.dist() %>% hclust(method = "average")
# Plot the eigengene dendrogram
sizeGrWindow(6, 6)
par(cex = 1.0)
plot(hclustdatME, main = "?rvore de clusteriza??o baseada nos atugenes dos m?dulos", xlab = "Altura")
# axis = axis(side=2, at = c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2), labels = format(c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2), decimal.mark=","))
par(cex = 1.0)
plotEigengeneNetworks(datME, "", marDendro = c(0, 4, 1, 2), marHeatmap = c(3, 4, 1, 2), cex.lab = 0.8, xLabelsAngle = 90)
# , axis = axis(side=4, at = c(0, 0.2,  0.4, 0.6, 0.8, 1), labels = format(c(0, 0.2,  0.4, 0.6, 0.8, 1), decimal.mark=","))
```


# Visualizing the gene network
```{r, fig.width=7, fig.height=7}
# One way to visualize a weighted network is to plot its heatmap
# Each  row  and  column  of  the  heatmap correspond to a single gene
# The heatmap can depict adjacencies or topological overlaps, with light colors denoting low adjacency (overlap) and darker colors higher adjacency (overlap).
# The gene dendrograms and module colors are plotted along the top and left side of the heatmap.
# Setting the diagonal to NA also improves the clarity of the plot

# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
# plotTOM <- dissTOM^7
# 
# diag(plotTOM) <- NA
# 
# TOMplot(plotTOM, geneTree, mergedColors)
```

# MDS plot
```{r, message=FALSE}
# multidimensional scaling
# Classical multidimensional scaling (MDS) of a data matrix. Also known as principal coordinates analysis

# cmd1 <- dissTOM %>% as.dist() %>% cmdscale(2)
# par(mfrow = c(1, 1))
# cmd1 %>% plot(col = as.character(mergedColors), main = "MDS plot", xlab = "Scaling Dimension 1", ylab = "Scaling Dimension 2", cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
```


# Diagnostics: heatmap plots of module expression
```{r}
which.module <- merge %>% .[["newMEs"]] %>% names() %>% gsub(pattern = "ME", replacement = "")
which.module_ME <- merge %>% .[["newMEs"]] %>% names()
ME <- map(seq_along(datME), function(i) datME %>% dplyr::select(which.module_ME[i])) %>% map(pull)

# We now create a heatmap plots of module expressions.

#library("gridExtra")
#grid.arrange(plot1, plot2, ncol=2)


# par(mfrow=c(2,2), mar=c(1, 2, 4, 1))
# for (i in 1:length(which.module)){
# plotMat(t(scale(datExpr[,moduleColors==which.module[[i]] ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module[[i]], title=which.module[[i]] )
# }
```

# Diagnostics: barplots of eigengene module expression
```{r, fig.width=7, fig.height=7}
# meanME <-

# ME %>% .[[1]] %>% (HibDesign$condition=="S01")

meanME <- list()
for (i in 1:length(which.module)) {
  meanME[[i]] <- as.vector(rbind(mean(ME[[i]][HibDesign$condition == "S01"]), mean(ME[[i]][HibDesign$condition == "S02"]), mean(ME[[i]][HibDesign$condition == "S03"]), mean(ME[[i]][HibDesign$condition == "S04"]), mean(ME[[i]][HibDesign$condition == "S05"]), mean(ME[[i]][HibDesign$condition == "S06"])))
}

sdME <- list()
for (i in 1:length(which.module)) {
  sdME[[i]] <- as.vector(rbind(sd(ME[[i]][HibDesign$condition == "S01"]), sd(ME[[i]][HibDesign$condition == "S02"]), sd(ME[[i]][HibDesign$condition == "S03"]), sd(ME[[i]][HibDesign$condition == "S04"]), sd(ME[[i]][HibDesign$condition == "S05"]), sd(ME[[i]][HibDesign$condition == "S06"])))
}

library(plotrix)
std.errorME <- list()
for (i in 1:length(which.module)) {
  std.errorME[[i]] <- as.vector(rbind(std.error(ME[[i]][HibDesign$condition == "S01"]), std.error(ME[[i]][HibDesign$condition == "S02"]), std.error(ME[[i]][HibDesign$condition == "S03"]), std.error(ME[[i]][HibDesign$condition == "S04"]), std.error(ME[[i]][HibDesign$condition == "S05"]), std.error(ME[[i]][HibDesign$condition == "S06"])))
}

# main=paste0("Expressão do autogene \n do módulo ", which.module[[i]])
# par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
par(mfrow = c(3, 3), mar = c(5.1, 4.1, 4.1, 2.1), cex.axis = 1.5, cex.lab = 1.2)

for (i in 1:length(which.module)) {
  MEbarplot <- barplot(meanME[[i]], col = which.module[[i]], main = "", cex.main = 1.2, cex.lab = 1.5, ylab = "Eigengene expression", xlab = "Samples", ylim = c(-0.7, 0.7))
  abline(h = 0, col = "black")
  arrows(MEbarplot, meanME[[i]] - std.errorME[[i]], MEbarplot,
    meanME[[i]] + std.errorME[[i]],
    lwd = 1.5, angle = 90,
    code = 3, length = 0.05
  )
}
```

# Diagnostics: displaying module eigengenes line plots
```{r, fig.width=7, fig.height=7}
scaled = datExpr %>% scale() %>% t()
```

# Diagnostics: displaying module heatmap and the eigengene
```{r, fig.width=7, fig.height=14}
# par(mfrow=c(3,1), mar=c(0.3, 5.5, 3, 2))
# 
# for (i in 1:length(which.module)){
# plotMat(t(scale(datExpr[,moduleColors==which.module[[i]] ]) ), nrgcols=30,rlabels=F,rcols=which.module[[i]], main=which.module[[i]], cex.main=2)
# 
# par(mar=c(5, 4.2, 0, 0.7))
# barplot(ME[[i]], col=which.module[[i]], main="", cex.main=2, cex.lab = 1.5, ylim=c(-0.7,0.7), ylab="Eigengene Expression",xlab="Samples")
# #axis = axis(side=2, at = c(-0.1, 0.1, 0.2, 0.3, 0.4), labels = format(c(-0.1, 0.1, 0.2, 0.3, 0.4), decimal.mark=","))
# 
# min_y = min(scaled)
# max_y = max(scaled)
# 
# # brown = scaled[moduleColors==which.module[[1]],][1,]
# 
# # spaghetti plot
# # plot(1:ncol(WGCNAtpm), WGCNAtpm[moduleColors==which.module[[i]],][1,], col=which.module[[i]], type="l", main="", cex.main=2, ylab="Eigengene Expression", cex.lab = 1.5, xlim=c(1,ncol(countData)), xlab="", ylim=c(min_y, max_y), xaxt='n')
# # axis = axis(side=1, at = 1:ncol(countData), labels = rownames(datExpr),las = 2)
# # title(xlab="Samples", line=4, cex.lab=1.5)
# # 
# # for (j in 2:nrow(WGCNAtpm[moduleColors==which.module[[i]],])){lines(1:ncol(WGCNAtpm), WGCNAtpm[moduleColors==which.module[[i]],][j,], col=which.module[[i]])}
# # lines(1:ncol(WGCNAtpm), ME[[i]],  col="black", type="l", lwd = 4)
# # }
# 
# plot(1:ncol(countData), scaled[moduleColors==which.module[[i]],][1,], col=which.module[[i]], type="l", main="", cex.main=2, ylab="Eigengene Expression", cex.lab = 1.5, xlim=c(1,ncol(countData)), xlab="", ylim=c(min_y, max_y), xaxt='n')
# axis = axis(side=1, at = 1:ncol(countData), labels = rownames(datExpr),las = 2)
# title(xlab="Samples", line=4, cex.lab=1.5)
# for (j in 2:nrow(scaled[moduleColors==which.module[[i]],])){lines(1:ncol(countData), scaled[moduleColors==which.module[[i]],][j,], col=which.module[[i]])}
# lines(1:ncol(countData), ME[[i]],  col="black", type="l", lwd = 4)
# }
```



# Diagnostics: displaying module eigengenes line plots
```{r, fig.width=7, fig.height=7}
#par(mfrow=c(3,3), mar=c(0.3, 5.5, 3, 2))
# par(mar=c(5, 4.2, 0, 0.7))
# 
# min_y = min(unlist(lapply(ME,FUN=min,na.rm=TRUE)))
# max_y = max(unlist(lapply(ME,FUN=max,na.rm=TRUE)))
# 
# plot(1:23, ME[[1]], col=which.module[[1]], type="l", main="", cex.main=2, ylab="Expressão do autogene",xlab="Amostra",xlim=c(0,24), ylim=c(min_y, max_y))
# for (i in 2:length(which.module)){lines(1:23, ME[[i]], col=which.module[[i]])}
# legend("topright", max_y, legend = c(which.module[[1]], which.module[[2]], which.module[[3]], which.module[[4]], which.module[[5]], which.module[[6]], which.module[[7]], which.module[[8]], which.module[[9]]), cex=0.5, col=c(which.module[[1]], which.module[[2]], which.module[[3]], which.module[[4]], which.module[[5]], which.module[[6]], which.module[[7]], which.module[[8]], which.module[[9]]), lty=1)
```

# The next logical step in an analysis of empirical data would be to carry out a functional enrichment analysis of each module

# Clusterprofiler
# KEGG over-representation test
# KEGG Enrichment Analysis of a gene set. Given a vector of genes, this function will return the enrichment KEGG categories with FDR control.
```{r, message=FALSE}
# names(modules_genes_Hib) = c(paste0("M",1:(length(modules)-1)))
# modules_genes_Hib$Not.Correlated = modules_genes_Hib[[length(modules_genes_Hib)]]
modules <- moduleblocks
modules_genes_Hib <- moduleblocks %>% purrr::set_names(paste0("M",1:(length(modules))))

Modules_KEGG_enrcihemnt <- modules_genes_Hib %>% compareCluster(fun = "enrichKEGG", organism = "hiu", pvalueCutoff = 1)

Modules_KEGG_enrcihemnt@compareClusterResult <- Modules_KEGG_enrcihemnt@compareClusterResult %>% 
  mutate(pvalue = pvalue %>% formattable::scientific(digits = 2, format = "e"),
         p.adjust = p.adjust %>% formattable::scientific(digits = 2, format = "e"),
         qvalue = qvalue %>% formattable::scientific(digits = 2, format = "e"))

Modules_KEGG_enrcihemnt@compareClusterResult <- Modules_KEGG_enrcihemnt@compareClusterResult %>% filter(p.adjust < 0.05) %>% filter(Count > 2)
Modules_KEGG_enrcihemnt_df = Modules_KEGG_enrcihemnt %>% as.data.frame()

# Modules_KEGG_enrcihemnt_df %>% write.table(file = "~/Dropbox/Hib_Data/Hib_WGCNA_clusterProfiler_Modules_enrichment.tsv", sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE )

```

```{r}
mar=c(5.1,4.1,4.1,2.1)
Modules_KEGG_enrcihemnt %>% dotplot(font.size = 10, includeAll=TRUE, showCategory=100)
```

# Classify DE genes into modules
```{r, fig.width=10, fig.height=7}

# DE_class = list()
# for(j in 1:length(moduleblocks)){DE_class[[j]] = intersect(topDE2[[15]]$Gene, rownames(moduleblocks[[j]])) } 
# names(DE_class) = c(paste0("M", 1:18), "Not.Correlated")
# # for(i in 1:length(topDE2)){ for(j in 1:length(moduleblocks)){DE_class[[i]][[j]] = intersect(topDE2[[i]]$Gene, rownames(moduleblocks[[j]])) } }
# 
# kk = compareCluster(DE_class, fun="enrichKEGG", organism = 'hiu', pvalueCutoff=0.05)
# modulesenrichKEGG = data.frame(kk)
# 
# mar=c(5.1,4.1,4.1,2.1)
# plot(kk, type="dot", font.size = 10, includeAll=TRUE, showCategory=100)
```

# Boxplots
```{r}
# genes <- Modules_KEGG_enrcihemnt_df %>% get_genes_from_pathways(pathway = "Citrate cycle (TCA cycle)", comparison = "M9")
# 
# set2$normalizedCounts %>% plot_genes_boxplot(genes = genes, design = HibDesign$condition, levels = c("S01", "S02", "S03", "S04", "S05", "S06"), converter = RefSeq_gff.genes, convert_from = "OldLocusTag", convert_to = "product")
```

# Boxplots
```{r}
# library(STRINGdb)
```

# Hubs
```{r, message=FALSE}
# # code adapted from https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-06-ExportNetwork.pdf
nTop <- 100
gene_names <- datExpr %>% colnames()
inModule <- map(seq_along(moduleblocks), function(i) gene_names %in% moduleblocks[[i]] )
# Select the corresponding Topological Overlap
modTOM <- map(seq_along(moduleblocks), function(i) TOM[inModule[[i]], inModule[[i]]] )
for (i in 1:length(moduleblocks)) { dimnames(modTOM[[i]]) <- list(moduleblocks[[i]], moduleblocks[[i]]) }

# Given expression data or a similarity, the function softConnectivity() constructs the adjacency matrix and for each node calculates its connectivity, that is the sum of the adjacency to the other nodes
# softConnectivity() returns a vector with one entry per gene giving the connectivity of each gene in the weighted network.

IMConn <- map(seq_along(moduleblocks), function(i) datExpr %>% as.data.frame %>% dplyr::select( c(moduleblocks[[i]])) %>% softConnectivity ) %>% map2(moduleblocks, purrr::set_names)

genes <- c("HIB_10030", "HIB_11690", "HIB_11840", "HIB_11830", "HIB_11680", "HIB_11670", "HIB_11820", "HIB_11660", "HIB_11810")

# top <- vector(mode = "list", length = length(moduleblocks))
# for (i in 1:length(moduleblocks)) {
#   top[[i]] <- (rank(-IMConn[[i]]) <= nTop)
# }
```

# Intramodular Connectivity
```{r}
# Calculates intramodular connectivity, i.e., connectivity of nodes to other nodes within the same module

# Returns a data frame with 4 columns giving:
# kTotal = the total connectivity, 
# kWithin = intramodular connectivity,
# kOut = extra-modular connectivity, and 
# kDiff = the difference of the intra and extra-modular connectivities for all genes

Alldegrees <- intramodularConnectivity(adjacency, moduleColors)
Alldegrees <- Alldegrees %>% rownames_to_column() %>% mutate_if(is.numeric, ~round(., digits = 2)) %>% column_to_rownames()

Hubness_by_module <- map(seq_along(moduleblocks), function(i) Alldegrees[moduleblocks[[i]],] ) %>% purrr::set_names(moduleblocks %>% names) %>% map(rownames_to_column) %>% map(arrange, -kTotal) %>% bind_rows(.id = "column_label")

Hubness_by_module %>% write.table(file = paste0("~/Dropbox/Hib_Data/Hib_WGCNA_Module_Hubs.tsv"), sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# map(seq_along(Hubness_by_module), function(i) Hubness_by_module[[i]] %>% write.table(file = paste0("~/Dropbox/Hib_Data/Hib_WGCNA_Module_", names(Hubness_by_module)[i],"_Hubs.tsv"), sep="\t", row.names = FALSE, col.names = TRUE, quote = FALSE) )
```

# Generalizing intramodular connectivity for all genes
```{r}
# The intramodular connectivity measure is only defined for the genes inside a given module. 
# But in practice it can be very important to measure how connected a given genes is to biologically interesting modules
# We define a module eigengene-based connectivity measure for each gene as the correlation between a the gene expression and the module eigengene

# We have a module membership value for each gene in each module
datKME=signedKME(datExpr, datME, outputColumnName="MM.")
head(datKME)
```

# Export data to Visant
```{r, message=FALSE}
#datMEcor = signif(cor(datME, use="p"), 2)
#exportNetworkToVisANT(datMEcor, file = "VisANTInput-eigengenes.txt", weighted = TRUE, threshold = 0)

#vis = vector(mode = "list", length = length(moduleblocks))
#for (i in 1:length(moduleblocks)){vis[[i]] = exportNetworkToVisANT(modTOM[[i]][top[[i]], top[[i]]], file = paste("VisANTInput-", module[[i]], "-top100.txt", sep=""), weighted = TRUE, threshold = 0)}
```

# Export data to Cytoscape
```{r, message=FALSE}
#cyt = vector(mode = "list", length = length(moduleblocks))
#for (i in 1:length(moduleblocks)){cyt[[i]] = exportNetworkToCytoscape(modTOM[[i]], edgeFile = paste("CytoscapeInput-edges-", paste(module[[i]], collapse="-"), ".txt", sep=""), nodeFile = paste("CytoscapeInput-nodes-", paste(module[[i]], collapse="-"), ".txt", sep=""), weighted = TRUE, threshold = 0.02, nodeNames = modGenes[[i]], altNodeNames = modGenes[[i]], nodeAttr = moduleColors[inModule[[i]]])}
```



# from Dados_Cultivo.R
# Data input and formating
```{r}
#HibPP = lapply(6:8, function(i){read.csv(paste0("~/Dropbox/Script/HibPP0", i, "-16.csv"), dec = ",",  sep = "\t", header = TRUE, quote = "")})
#HibPP[[4]] = read.csv("~/Dropbox/Script/HibPP02-17.csv", dec = ",", header=TRUE, sep="\t", quote="")

HibPP = lapply(6:8, function(i){read.csv(paste0("~/Dropbox/Hib_Data/HibPP0", i, "-16.csv"), dec = ",",  sep = "\t", header = TRUE, quote = "")})
HibPP[[4]] = read.csv("~/Dropbox/Hib_Data/HibPP02-17.csv", dec = ",", header=TRUE, sep="\t", quote="")
points = c(3, 9, 11, 12, 16, 21)
cores = c("blue", "red", "black", "purple", "magenta", "darkblue")

is.na(HibPP[[1]][,17])

HibPP[[1]][,21] = c(0, -0.435, -0.062, 0.220, 0.324, 0.306, 0.414, 0.586, 0.762, 0.897, 1.094, 0.889, -0.042, 0.092, 0.240, 0.345, NA, NA, 0.274, 0.241, 0.248, -0.203)

HibPP[[2]][,21] = c(0, 0.026, -0.247, 1.816, -1.320, 0.729, 0.226, 0.851, 1.041, 1.225, 0.973, -0.344, -0.408, -0.052, 0.174, 0.194, 0.334, 0.318, 0.177, 0.605, -0.290, -0.042)

HibPP[[3]][,21] = c(0, -0.036, 0.187, 0.183, 0.264, 0.289, 0.269, 1.046, 1.039, 1.116, 1.003, 0.029, -0.247, 0.007, 0.212, 0.373, 0.142, 0.194, 0.327, 0.234, 0.136, 0.086)

HibPP[[4]][,21] = c(0, -0.628, 0.050, 0.236, 0.207, 0.220, 0.516, 0.517, 0.829, 0.702, 0.822, 0.250, -0.057, 0.079, 0.137, 0.236, 0.236, 0.128, 0.233, 0.034, 0.225, 0.084)

```

# All HibPP_Variables
```{r, message=FALSE}
HibPP_Variables <- map(HibPP, function(df) {
  df %>% dplyr::select(c(2, 9, 7, 13, 15, 11, 12, 21, 16)) %>%
    purrr::set_names(c("EFT", "CO2", "O2", "Acetate", "PRP", "Biomass", "Glucose", "Glucose_consumption", "Molecular_mass")) %>%
    mutate(
      CO2 = CO2 %>% gsub(pattern = "%", replacement = "") %>% gsub(pattern = ",", replacement = ".", fixed = TRUE) %>% as.numeric,
      O2 = O2 %>% gsub(pattern = "%", replacement = "") %>% gsub(pattern = ",", replacement = ".", fixed = TRUE) %>% as.numeric,
      Delta_EFT = c(NA, diff(EFT)),
      # Delta_CO2 = c(NA, diff(CO2)),
      # Delta_O2 = c(NA, diff(O2)),
      Delta_Acetate = c(NA, diff(Acetate)),
      Delta_PRP = c(NA, diff(PRP)),
      Delta_Biomass = c(NA, diff(Biomass)),
      Delta_Glucose = c(NA, diff(Glucose)),
      Delta_Glucose_consumption = c(NA, diff(Glucose_consumption)),
      rx = Delta_Biomass / Delta_EFT, # Crescimento específico
      rsG = Delta_Glucose_consumption / Delta_EFT, # velocidades instantaneas de consumo
      rsPRP = Delta_PRP / Delta_EFT, # velocidades instantaneas de formacao de produto (PRP)
      rsAc = Delta_Acetate / Delta_EFT, # velocidades instantaneas de formacao de produto (Ac)
      Px = (Biomass - Biomass[2]) / EFT,
      PpAc = (Acetate - Acetate[2]) / EFT, # produtividade do produto (Acetato)
      PpPRP = (PRP - PRP[2]) / EFT, # produtividade do produto (PRP)
      MiX = rx / Biomass, # velocidades especificas de crescimento
      MiS = -1 * rsG / Biomass, # velocidades especificas de consumo de substrato
      MiPAc = rsAc / Biomass, # velocidades especificas de formacao de produto (PRP)
      MiPPRP = rsPRP / Biomass, # velocidades especificas de formacao de produto (PRP)
      Yxs = -1 * Delta_Biomass / Delta_Glucose_consumption,
      YxpAc = Delta_Biomass / Delta_Acetate,
      YxpPRP = Delta_Biomass / Delta_PRP,
      YpsAc = -1 * Delta_Acetate / Delta_Glucose_consumption,
      YpsPRP = -1 * Delta_PRP / Delta_Glucose_consumption
    )
}) %>% purrr::set_names(c("B01", "B02", "B03", "B04"))
HibPP_Variables <- map(seq_along(HibPP_Variables), function(i) HibPP_Variables[[i]] %>%
    mutate(Batch = rep(paste0("B0", i), nrow(HibPP_Variables[[i]])), Time = paste0(0:21, "h"))) # Categorical values: Batch, Time

HibPP_Variables <- ldply(HibPP_Variables, data.frame)
HibPP_Variables[HibPP_Variables == -Inf] <- NA

HibPP_Variables <- HibPP_Variables %>% as_tibble()
HibPP_Variables <- HibPP_Variables %>% mutate(
  Time = Time %>% factor(levels = c("0h", "1h", "2h", "3h", "4h", "5h", "6h", "7h", "8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h", "16h", "17h", "18h", "19h", "20h", "21h")),
  Molecular_mass = Molecular_mass %>% as.numeric()
)

HibPP_Variables_Samples <- HibPP_Variables %>% split(f = .$Batch) %>% map(dplyr::slice, points) %>% map(dplyr::select, -c(Batch, Time))
HibPP_Variables_Vector <- ldply(HibPP_Variables_Samples, data.frame) %>% dplyr::select(-c(.id)) %>% as.list()

# HibPP_Variables %>% melt() %>% View()
# HibPP_Variables %>% ggplot(aes(x = Time, y = PRP)) + geom_boxplot() + geom_jitter(aes(colour = Batch)) + theme_bw()
# HibPP_Variables %>% ggplot(aes(x = Time, y = Acetate)) + geom_boxplot() + geom_jitter(aes(colour = Batch)) + theme_bw()
# HibPP_Variables %>% ggplot(aes(x = Time, y = CO2)) + geom_boxplot() + geom_jitter(aes(colour = Batch)) + theme_bw()
# HibPP_Variables %>% ggplot(aes(x = Time, y = Biomass)) + geom_boxplot() + geom_jitter(aes(colour = Batch)) + theme_bw()

HibPP_Variables_2_plot <- list(
  HibPP_Variables %>% dplyr::select(c(2:5, 32:33)),
  HibPP_Variables %>% dplyr::select(c(6:9, 32:33)),
  HibPP_Variables %>% dplyr::select(c(10:13, 32:33)),
  HibPP_Variables %>% dplyr::select(c(14:17, 32:33)),
  HibPP_Variables %>% dplyr::select(c(18:21, 32:33)),
  HibPP_Variables %>% dplyr::select(c(22:25, 32:33)),
  HibPP_Variables %>% dplyr::select(c(26:29, 32:33)),
  HibPP_Variables %>% dplyr::select(c(30:31, 32:33))
)

HibPP_Variables_2_plot <- HibPP_Variables_2_plot %>% map(melt)

HibPP_Variables_2_plot %>% map(function(x) ggplot(x, aes(x = Time, y = value)) + geom_boxplot() + geom_jitter(aes(colour = Batch)) + theme_bw() + facet_wrap(~variable, scales = "free", ncol = 1))

# HibPP_Variables_Vector <- map(1:ncol(HibPP_Variables_Samples[[1]]), function(j) as.vector(sapply(1:4, function(i) {
#     cbind(HibPP_Variables_Samples[[i]][, j])
#   })))

map(HibPP_Variables_Samples, function(df) {
  c(mean(df %>% dplyr::select(-EFT)), var(df %>% dplyr::select(-EFT)), std.error(df %>% dplyr::select(-EFT)))
})

Mean_HibPP_Variables <- aaply(laply(HibPP_Variables, as.matrix), c(2, 3), .fun = mean, na.rm = TRUE)
SE_HibPP_Variables <- aaply(laply(HibPP_Variables, as.matrix), c(2, 3), .fun = std.error, na.rm = TRUE)
CI.up <- Mean_HibPP_Variables + SE_HibPP_Variables
CI.dn <- Mean_HibPP_Variables - SE_HibPP_Variables

# HibPP_Variables = lapply(1:4, function(i){as.data.frame(cbind(HibPP[[i]][,2], HibPP[[i]][,9], HibPP[[i]][,7], HibPP[[i]][,13], HibPP[[i]][,15], HibPP[[i]][,11], HibPP[[i]][,12], HibPP[[i]][,21], HibPP[[i]][,16]))})
# names(HibPP_Variables) = c("B01", "B02", "B03", "B04")
# HibPP_Variables = lapply(HibPP_Variables, setNames, nm = c("EFT", "CO2", "O2", "Acetate", "PRP", "Biomass", "Glucose", "Glucose_consumption", "Molecular_mass"))
# HibPP_Variables = lapply(HibPP_Variables, function(x) apply(x, 2, function(y) gsub("%", "", y))) # remove "%"
# options(digits=4)
# HibPP_Variables = lapply(HibPP_Variables, function(x) apply(x, 2, function(y) as.numeric(sub(",", ".", y, fixed = TRUE)))) # substitute "," for "."

# Diff = lapply(HibPP_Variables, function(x) apply(x, 2, diff)) # Delta of values
# Diff = lapply(1:length(Diff), function(i) rbind(NA, Diff[[i]]) )

# HibPP_Variables = lapply(1:length(Diff), function(i) cbind(HibPP_Variables[[i]], Diff[[i]][,2:8]) )

# HibPP_Variables = lapply(HibPP_Variables, setNames, c("EFT", "CO2", "O2", "Acetate", "PRP", "Biomass", "Glucose", "Glucose_consumption", "Molecular_mass", "Delta_CO2", "Delta_O2", "Delta_Acetate", "Delta_PRP", "Delta_Biomass", "Delta_Glucose", "Delta_Glucose_consumption"))

# names(HibPP_Variables_Vector) = c("EFT", "CO2", "O2", "Acetate", "PRP", "Biomass", "Glucose", "Glucose_consumption", "Molecular_mass")

# velocidades instantaneas de crescimento/ Crescimento espec???????fico
# rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
# rxv = lapply(1:4, function(i){rx[,i]})

# lapply(HibPP_Variables, function(i) apply(2:22, 2, function(j) i[,7][j] = CO2[j] - CO2[j-1]))
```

# Plots
```{r}
max_y <- max(sapply(HibPP_Variables, function(x) max(x[, 2]))) # Compute the largest y value used in the data
# max(unlist(lapply(HibPP_Variables[[1]][,2],FUN=max,na.rm=TRUE)))
xmax <- max(sapply(HibPP_Variables, function(x) max(x[, 1]))) # Compute the largest x value used in the data
# max(unlist(lapply(EFTv,FUN=max,na.rm=TRUE)))
plot(HibPP_Variables[[1]][, 1], HibPP_Variables[[1]][, 2], type = "o", pch = 21, lty = 1, xlab = "Time (h)", ylab = expression("[" ~ CO[2] ~ "] (%)"), main = expression(~ CO[2] ~ "concentration during cultivation"), col = cores[1], xlim = c(0, xmax), ylim = c(0, max_y))
# box() # Create box around plot
# lapply(2:4, function(i){lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4) {
  lines(HibPP_Variables[[i]][, 2], type = "o", pch = 20 + i, lty = i, col = cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("bottomright", max_y, legend = c("B01", "B02", "B03", "B04"), cex = 0.7, col = c(cores[1], cores[2], cores[3], cores[4]), pch = 21:24, lty = 1:4)

par(mar = c(6, 6, 3, 3), cex.axis = 1.5, cex.lab = 1.2)
max_y <- max(sapply(HibPP_Variables, function(x) max(x[, 2]))) # Compute the largest y value used in the data
xmax <- max(sapply(HibPP_Variables, function(x) max(x[, 1]))) # Compute the largest x value used in the data
plot(Mean_HibPP_Variables[, 1], Mean_HibPP_Variables[, 2], type = "o", pch = 21, lty = 1, xlab = "Time (h)", ylab = expression("[" ~ CO[2] ~ "] (%)"), main = expression(CO[2] ~ " Concentration during cultivation"), col = cores[1], xlim = c(0, xmax), ylim = c(0, max_y))
arrows(Mean_HibPP_Variables[, 1], CI.dn[, 2], Mean_HibPP_Variables[, 1], CI.up[, 2], code = 3, length = 0.1, angle = 90, col = "black")

# library(ggplot2)
# pd <- position_dodge(.3)
# ggplot(Mean_HibPP_Variables, aes(x=EFT, y=CO2, group=CO2)) + geom_errorbar(aes(ymin=CO2-SE_HibPP_Variables[,2], ymax=CO2+SE_HibPP_Variables[,2]),                   width=.2, size=0.25, colour="black", position=pd) + geom_line(position=pd) + geom_point(position=pd, size=2.5)
```

# datTraits
```{r}
nGenes <- datExpr %>% ncol()
nSamples <- datExpr %>% nrow()

# datTraits <- data.frame(
#   "Biomass" = HibPP_Variables_Vector$Biomass,
#   "Acetate" = HibPP_Variables_Vector$Acetate,
#   "Glucose" = HibPP_Variables_Vector$Glucose,
#   "Consumed Glucose" = HibPP_Variables_Vector$Glucose_consumption,
#   "PRP" = HibPP_Variables_Vector$PRP,
#   "CO2" = HibPP_Variables_Vector$CO2,
#   "Massa Molecular" = HibPP_Variables_Vector$Molecular_mass
# )

datTraits <- data.frame(
  "Massa Seca" = HibPP_Variables_Vector$Biomass,
  "[Acetato]" = HibPP_Variables_Vector$Acetate,
  "[Glicose]" = HibPP_Variables_Vector$Glucose,
  "[Glicose Consumida]" = HibPP_Variables_Vector$Glucose_consumption,
  "[PRP]" = HibPP_Variables_Vector$PRP,
  "[CO2]" = HibPP_Variables_Vector$CO2,
  "Massa Molecular" = HibPP_Variables_Vector$Molecular_mass,
  "Crescimento Especifico" = HibPP_Variables_Vector$rx,
  "Velocidade Instantanea de Consumo de Substrato" = HibPP_Variables_Vector$rsG,
  "Velocidade Instantanea de Formacao de PRP" = HibPP_Variables_Vector$rsPRP,
  "Velocidade Instantanea de Formacao de Acetato" = HibPP_Variables_Vector$rsAc,
  "Velocidade Instantanea de Crescimento referente ao tempo" = HibPP_Variables_Vector$Px,
  "Produtividade de PRP" = HibPP_Variables_Vector$PpPRP,
  "Produtividade de Acetato" = HibPP_Variables_Vector$PpAc
  # "Velocidade Especifica de Crescimento" = HibPP_Variables_Vector$MiX,
  # "Velocidade Especifica de Consumo de Substrato" = HibPP_Variables_Vector$MiS,
  # "Velocidade Especifica de Formacao de Acetato" = HibPP_Variables_Vector$MiPAc,
  # "Velocidade Especifica de Formacao de PRP" = HibPP_Variables_Vector$MiPPRP,
  # "Coeficiente Especifico de Biomassa-Glicose" = HibPP_Variables_Vector$Yxs,
  # "Coeficiente Especifico de Biomassa-Acetato" = HibPP_Variables_Vector$YxpAc,
  # "Coeficiente Especifico de Biomassa-PRP" = HibPP_Variables_Vector$YxpPRP,
  # "Coeficiente Especifico de Acetato-Glicose" = HibPP_Variables_Vector$YpsAc,
  # "Coeficiente Especifico de PRP-Glicose" = HibPP_Variables_Vector$YpsPRP
)

datTraits <- datTraits %>% dplyr::slice(-c(10))

datTraits[datTraits == -Inf] <- NA

MEs_M <- MEs %>% purrr::set_names(paste0("M", 1:(length(modules))))

moduleTraitCor <- cor(MEs_M, datTraits, use = "pairwise.complete.obs")

moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)

# a suitable graphical representation will help in reading the table
# We color code each association by the correlation value
# Will display correlations and their p-values

textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")

xL <- c("[Biomass]", "[Acetate]", "[Glucose]", "[Consumed Glucose]", "[PRP]", "[CO2]", "Massa Molecular")

xL <- c(
  "Dry weight",
  "[Acetate]",
  "[Glucose]",
  "[Glicose uptaken]", 
  "[PRP]", 
  "[CO2]", 
  "Molecular Mass", 
  "Specific Growth", 
  "Instantaneous Substrate \n Consumption Speed", 
  "Instantaneous PRP \n Production Speed", 
  "Instantaneous Acetate \n Production Speed", 
  "Instantaneous Growth Rate \n relative to time", 
  "PRP Produtivity", 
  "Acetate Produtivity"
  # "Velocidade Especifica de Crescimento", 
  # "Velocidade Especifica de Consumo de Substrato", 
  # "Velocidade Especifica de Formacao de Acetato", 
  # "Velocidade Especifica de Formacao de PRP", 
  # "Coeficiente Especifico de Biomassa-Glicose", 
  # "Coeficiente Especifico de Biomassa-Acetato", 
  # "Coeficiente Especifico de Biomassa-PRP", 
  # "Coeficiente Especifico de Acetato-Glicose", 
  # "Coeficiente Especifico de PRP-Glicose"
)

# par(mar = c(12, 5, 4, 2)+ 0.1)
par(mar = c(6, 8.8, 3, 2.2) + 5)
moduleTraitCor %>% labeledHeatmap(xLabels = xL, yLabels = names(MEs), ySymbols = names(MEs_M), colorLabels = FALSE, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = FALSE, cex.text = 0.6, zlim = c(-1, 1), main = paste("Kinetic parameters - Modules relationship"), xLabelsAngle = 45)
```

























# EFT
```{r}
EFT = lapply(1:4, function(i){HibPP[[i]][,2]})
EFTv = lapply(1:4, function(i){as.numeric(sub(",", ".", EFT[[i]], fixed = TRUE))})
EFTs = lapply(1:4, function(i){EFTv[[i]][points]})
xmax = max(unlist(lapply(EFTv,FUN=max,na.rm=TRUE)))
```

# DeltaEFT
```{r}
DeltaEFT = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaEFT[[i]][j] = EFTv[[i]][j]-EFTv[[i]][j-1]}}
```

# [CO2]
```{r, message=FALSE}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
CO2 = lapply(1:4, function(i){HibPP[[i]][,9]})
CO2[] <- lapply(CO2, as.character)
CO2sem = lapply(1:4, function(i){substr(CO2[[i]], 1, nchar(CO2[[i]])-1)})
CO2v = lapply(1:4, function(i){as.numeric(sub(",", ".", CO2sem[[i]], fixed = TRUE))})
CO2s = lapply(1:4, function(i){CO2v[[i]][points]})
CO2t = as.vector(sapply(1:4, function(i){cbind(CO2s[[i]])}))

max_y = max(unlist(lapply(CO2v,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], CO2v[[1]], type="o", pch=21, lty = 1, xlab="Time (h)", ylab=expression("[" ~ CO[2] ~ "] (%)"), main = expression( ~ CO[2] ~ "concentration during cultivation"), col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(CO2v[[i]], type="o", pch=20+i, lty = i, col=cores[i])  
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("bottomright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
library("plotrix")
CO2tMean = CO2tstd.error = MeanEFT = vector()

for (i in 1:21){
  CO2tMean[i] = mean(c(CO2v[[1]][i], CO2v[[2]][i], CO2v[[3]][i], CO2v[[4]][i]))
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  CO2tstd.error[i] = std.error(c(CO2v[[1]][i], CO2v[[2]][i], CO2v[[3]][i], CO2v[[4]][i]))
}

CI.up = CO2tMean+CO2tstd.error
CI.dn = CO2tMean-CO2tstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(CO2tMean+CO2tstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, CO2tMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[" ~ CO[2] ~ "] (%)"), main = expression("Concentração de" ~ CO[2] ~ " durante o cultivo"), col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# DeltaCO2
```{r}
DeltaCO2 = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaCO2[[i]][j] = CO2v[[i]][j]-CO2v[[i]][j-1]}}
```


# [O2]
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
O2 = lapply(1:4, function(i){HibPP[[i]][,7]})
O2[] <- lapply(O2, as.character)
O2sem = lapply(1:4, function(i){substr(O2[[i]], 1, nchar(O2[[i]])-1)})
O2v = lapply(1:4, function(i){as.numeric(sub(",", ".", O2sem[[i]], fixed = TRUE))})
O2s = lapply(1:4, function(i){O2v[[i]][points]})
O2t = as.vector(sapply(1:4, function(i){cbind(O2s[[i]])}))

max_y = max(unlist(lapply(O2v,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], O2v[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[" ~ O[2] ~ "] (%)"), main = expression("Concentra??o de" ~ O[2] ~ " durante o cultivo"), col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(O2v[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

# DeltaO2
```{r}
DeltaO2 = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaO2[[i]][j] = O2v[[i]][j]-O2v[[i]][j-1]}}
```

# [Acetato]
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
Acetato = lapply(1:4, function(i){HibPP[[i]][,13]})
Acetatov = lapply(1:4, function(i){as.numeric(sub(",", ".", Acetato[[i]], fixed = TRUE))})
Acetatos = lapply(1:4, function(i){Acetatov[[i]][points]})
Acetatot = as.vector(sapply(1:4, function(i){cbind(Acetatos[[i]])}))

max_y = max(unlist(lapply(Acetatov,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], Acetatov[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression("[Acetato] " ~ (g.L^{-1})), main = "Concentração de Acetato produzido", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
AcetatovMean = Acetatovstd.error = MeanEFT = vector()

for (i in 1:21){
  AcetatovMean[i] = mean(c(Acetatov[[1]][i], Acetatov[[2]][i], Acetatov[[3]][i], Acetatov[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  Acetatovstd.error[i] = std.error(c(Acetatov[[1]][i], Acetatov[[2]][i], Acetatov[[3]][i], Acetatov[[4]][i]), na.rm=TRUE)
}

CI.up = AcetatovMean+Acetatovstd.error
CI.dn = AcetatovMean-Acetatovstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(AcetatovMean+Acetatovstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, AcetatovMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression("[Acetato] " ~ (g.L^{-1})), main = "Concentração de Acetato produzido", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# DeltaAcetato
```{r}
DeltaAcetato = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaAcetato[[i]][j] = Acetatov[[i]][j]-Acetatov[[i]][j-1]}}
```

# [PRP]
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
PRP = lapply(1:4, function(i){HibPP[[i]][,15]})
PRPv = lapply(1:4, function(i){as.numeric(sub(",", ".", PRP[[i]], fixed = TRUE))})
PRPs = lapply(1:4, function(i){PRPv[[i]][points]})
PRPt = as.vector(sapply(1:4, function(i){cbind(PRPs[[i]])}))

max_y = max(unlist(lapply(PRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], PRPv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[PRP] " ~ (g.L^{-1})), main = "Concentra??oo de PRP produzido", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(PRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
PRPvMean = PRPvstd.error = MeanEFT = vector()

for (i in 1:21){
  PRPvMean[i] = mean(c(PRPv[[1]][i], PRPv[[2]][i], PRPv[[3]][i], PRPv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  PRPvstd.error[i] = std.error(c(PRPv[[1]][i], PRPv[[2]][i], PRPv[[3]][i], PRPv[[4]][i]), na.rm=TRUE)
}

CI.up = PRPvMean+PRPvstd.error
CI.dn = PRPvMean-PRPvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(PRPvMean+PRPvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, PRPvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression("[PRP] " ~ (g.L^{-1})), main = "Concentração de PRP produzido", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# DeltaPRP
```{r}
DeltaPRP = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaPRP[[i]][j] = PRPv[[i]][j]-PRPv[[i]][j-1]}}
```

# Biomassa Seca
```{r}
cores1 = c("blue", "red", "black", "purple")
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.5)
Massa = lapply(1:4, function(i){HibPP[[i]][,11]})
Massav = lapply(1:4, function(i){as.numeric(sub(",", ".", Massa[[i]], fixed = TRUE))})
Massas = lapply(1:4, function(i){Massav[[i]][points]})
Massat = as.vector(sapply(1:4, function(i){cbind(Massas[[i]])}))

max_y = max(unlist(lapply(Massav,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], Massav[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("Concentração de Biomassa " ~ (g.L^{-1})), main = "Perfil de Crescimento", col = cores1[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(Massav[[i]], type="o", pch=20+i, lty = i, col=cores1[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("B01", "B02", "B03", "B04"), cex=1, col=c(cores1[1], cores1[2], cores1[3], cores1[4]), text.col = c(cores1[1], cores1[2], cores1[3], cores1[4]), pch=21:24, lty=1:4)
```

```{r}
MassavMean = Massavstd.error = MeanEFT = vector()

for (i in 1:21){
  MassavMean[i] = mean(c(Massav[[1]][i], Massav[[2]][i], Massav[[3]][i], Massav[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  Massavstd.error[i] = std.error(c(Massav[[1]][i], Massav[[2]][i], Massav[[3]][i], Massav[[4]][i]), na.rm=TRUE)
}

CI.up = MassavMean+Massavstd.error
CI.dn = MassavMean-Massavstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(MassavMean+Massavstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, MassavMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression("Concentração de Biomassa " ~ (g.L^{-1})), main = "Perfil de Crescimento", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```




# DeltaMassa
```{r}
DeltaMassa = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaMassa[[i]][j] = Massav[[i]][j]-Massav[[i]][j-1]}}
```

# [Glicose]
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
Glicose = lapply(1:4, function(i){HibPP[[i]][,12]})
Glicosev = lapply(1:4, function(i){as.numeric(sub(",", ".", Glicose[[i]], fixed = TRUE))})
Glicoses = lapply(1:4, function(i){Glicosev[[i]][points]})
Glicoset = as.vector(sapply(1:4, function(i){cbind(Glicoses[[i]])}))

max_y = max(unlist(lapply(Glicosev,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], Glicosev[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[Glicose] " ~ (g.L^{-1})), main = "Concentração de Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(Glicosev[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
GlicosevMean = Glicosevstd.error = MeanEFT = vector()

for (i in 1:21){
  GlicosevMean[i] = mean(c(Glicosev[[1]][i], Glicosev[[2]][i], Glicosev[[3]][i], Glicosev[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  Glicosevstd.error[i] = std.error(c(Glicosev[[1]][i], Glicosev[[2]][i], Glicosev[[3]][i], Glicosev[[4]][i]), na.rm=TRUE)
}

CI.up = GlicosevMean+Glicosevstd.error
CI.dn = GlicosevMean-Glicosevstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(GlicosevMean+Glicosevstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, GlicosevMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[Glicose] " ~ (g.L^{-1})), main = "Concentração de Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# [ConsumoGlicose]
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
CGlicose = lapply(1:4, function(i){HibPP[[i]][,21]})
CGlicosev = lapply(1:4, function(i){as.numeric(sub(",", ".", CGlicose[[i]], fixed = TRUE))})
CGlicoses = lapply(1:4, function(i){CGlicosev[[i]][points]})
CGlicoset = as.vector(sapply(1:4, function(i){cbind(CGlicoses[[i]])}))

max_y = max(unlist(lapply(CGlicosev,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(EFTv[[1]], CGlicosev[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[Glicose Consumida] " ~ (g.L^{-1})), main = "Concentração de Glicose Consumida", col = cores[1],  xlim=c(0, xmax), ylim=c(-1, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(CGlicosev[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
CGlicosevMean = CGlicosevstd.error = MeanEFT = vector()

for (i in 1:21){
  CGlicosevMean[i] = mean(c(CGlicosev[[1]][i], CGlicosev[[2]][i], CGlicosev[[3]][i], CGlicosev[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  CGlicosevstd.error[i] = std.error(c(CGlicosev[[1]][i], CGlicosev[[2]][i], CGlicosev[[3]][i], CGlicosev[[4]][i]), na.rm=TRUE)
}

CI.up = CGlicosevMean+CGlicosevstd.error
CI.dn = CGlicosevMean-CGlicosevstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(CGlicosevMean+CGlicosevstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(CGlicosevMean-CGlicosevstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, CGlicosevMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("[Glicose Consumida] " ~ (g.L^{-1})), main = "Concentração de Glicose Consumida", col = "black",  xlim=c(0, xmax), ylim=c(min_y, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# DeltaGlicose
```{r}
DeltaGlicose = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaGlicose[[i]][j] = Glicosev[[i]][j]-Glicosev[[i]][j-1]}}
```

# DeltaCGlicose
```{r}
DeltaCGlicose = vector(mode = "list", length = 4)
for(i in 1:4){for(j in 2:22){DeltaCGlicose[[i]][j] = CGlicosev[[i]][j]-CGlicosev[[i]][j-1]}}
```

# [MM]
```{r}
MM = lapply(1:4, function(i){HibPP[[i]][,16]})
MMv = lapply(1:4, function(i){as.numeric(sub(",", ".", MM[[i]], fixed = TRUE))})
MMs = lapply(1:4, function(i){MMv[[i]][points]})
MMt = as.vector(sapply(1:4, function(i){cbind(MMs[[i]])}))
```

# velocidades instantaneas de crescimento/ Crescimento espec???????fico
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
rx = cbind(DeltaMassa[[1]]/DeltaEFT[[1]], DeltaMassa[[2]]/DeltaEFT[[2]], DeltaMassa[[3]]/DeltaEFT[[3]], DeltaMassa[[4]]/DeltaEFT[[4]])
rxv = lapply(1:4, function(i){rx[,i]})

max_y = max(unlist(lapply(rxv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rxv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rxv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Crescimento Específico (g." ~ L^-1 ~ ")")), main = "Crescimento Específico", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(rxv[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


```{r}
rxvMean = rxvstd.error = MeanEFT = vector()

for (i in 1:21){
  rxvMean[i] = mean(c(rxv[[1]][i], rxv[[2]][i], rxv[[3]][i], rxv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  rxvstd.error[i] = std.error(c(rxv[[1]][i], rxv[[2]][i], rxv[[3]][i], rxv[[4]][i]), na.rm=TRUE)
}

CI.up = rxvMean+rxvstd.error
CI.dn = rxvMean-rxvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(rxvMean+rxvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, rxvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Crescimento Específico (g." ~ L^-1 ~ ")")), main = "Crescimento Específico", col='black',  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# velocidades instantaneas de consumo de substrato
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
rsG = -1*(cbind(DeltaCGlicose[[1]]/DeltaEFT[[1]], DeltaCGlicose[[2]]/DeltaEFT[[2]], DeltaCGlicose[[3]]/DeltaEFT[[3]], DeltaCGlicose[[4]]/DeltaEFT[[4]]))

rsGv = lapply(1:4, function(i){rsG[,i]})

max_y = max(unlist(lapply(rsGv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rsGv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rsGv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression("Consumo de Substrato " ~ (g.L^{-1})), main = "Velocidade Instantânea de Consumo de Substrato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
#lapply(2:4, function(i){lines(Acetatov[[i]], type="o", pch=20+i, lty = i, col=rainbow(i))})
for (i in 2:4){
  lines(rsGv[[i]], type="o", pch=20+i, lty = i, col=cores[i])
}
# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
rsGvMean = rsGvstd.error = MeanEFT = vector()

for (i in 1:21){
  rsGvMean[i] = mean(c(rsGv[[1]][i], rsGv[[2]][i], rsGv[[3]][i], rsGv[[4]][i]), na.rm=TRUE)
}

rsGvMean[1] = NA

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  rsGvstd.error[i] = std.error(c(rsGv[[1]][i], rsGv[[2]][i], rsGv[[3]][i], rsGv[[4]][i]), na.rm=TRUE)
}

CI.up = rsGvMean+rsGvstd.error
CI.dn = rsGvMean-rsGvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(rsGvMean+rsGvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, rsGvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression("Consumo de Substrato " ~ (g.L^{-1})), main = "Velocidade Instantânea de Consumo de Substrato", col='black',  xlim=c(0, xmax), ylim=c(-1.5, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```


# velocidades instantaneas de formacao de produto (PRP)
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
rsPRP = cbind(DeltaPRP[[1]]/DeltaEFT[[1]], DeltaPRP[[2]]/DeltaEFT[[2]], DeltaPRP[[3]]/DeltaEFT[[3]], DeltaPRP[[4]]/DeltaEFT[[4]])

rsPRPv = lapply(1:4, function(i){rsPRP[,i]})

max_y = max(unlist(lapply(rsPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rsPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rsPRPv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("Formação de PRP " ~ (g.L^{-1}~h^{-1})), main = "Velocidade Instantânea de Formação de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(rsPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
rsPRPvMean = rsPRPvstd.error = MeanEFT = vector()

for (i in 1:21){
  rsPRPvMean[i] = mean(c(rsPRPv[[1]][i], rsPRPv[[2]][i], rsPRPv[[3]][i], rsPRPv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  rsPRPvstd.error[i] = std.error(c(rsPRPv[[1]][i], rsPRPv[[2]][i], rsPRPv[[3]][i], rsPRPv[[4]][i]), na.rm=TRUE)
}

CI.up = rsPRPvMean+rsPRPvstd.error
CI.dn = rsPRPvMean-rsPRPvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(rsPRPvMean+rsPRPvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, rsPRPvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("Formação de PRP " ~ (g.L^{-1}~h^{-1})), main = "Velocidade Instantânea de Formação de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```


# velocidades instantaneas de formacao de produto (Acetato)
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
rsAc = cbind(DeltaAcetato[[1]]/DeltaEFT[[1]], DeltaAcetato[[2]]/DeltaEFT[[2]], DeltaAcetato[[3]]/DeltaEFT[[3]], DeltaAcetato[[4]])

rsAcv = lapply(1:4, function(i){rsAc[,i]})

max_y = max(unlist(lapply(rsAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(rsAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], rsAcv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("Forma??o de Acetato " ~ (g.L^{-1}~h^{-1})), main = "Velocidade Instant?nea de Forma??o de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(rsAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
rsAcvMean = rsAcvstd.error = MeanEFT = vector()

for (i in 1:21){
  rsAcvMean[i] = mean(c(rsAcv[[1]][i], rsAcv[[2]][i], rsAcv[[3]][i], rsAcv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  rsAcvstd.error[i] = std.error(c(rsAcv[[1]][i], rsAcv[[2]][i], rsAcv[[3]][i], rsAcv[[4]][i]), na.rm=TRUE)
}

CI.up = rsAcvMean+rsAcvstd.error
CI.dn = rsAcvMean-rsAcvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(rsAcvMean+rsAcvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, rsAcvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression("Formação de Acetato " ~ (g.L^{-1}~h^{-1})), main = "Velocidade Instantânea de Formação de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# produtividade em biomassa -> velocidade media de crescimento referente ao tempo .total ou final de fermentacao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
Px = cbind((Massav[[1]]-Massav[[1]][2])/EFT[[1]], (Massav[[2]]-Massav[[2]][2])/EFT[[2]],(Massav[[3]]-Massav[[3]][2])/EFT[[3]],(Massav[[4]]-Massav[[4]][2])/EFT[[4]])

Pxv = lapply(1:4, function(i){Px[,i]})

max_y = max(unlist(lapply(Pxv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
#min_y = min(unlist(lapply(Pxv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], Pxv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression(atop("Produtividade em", "Biomassa " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Instantânea de \n Crescimento referente ao tempo", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
for (i in 2:4){lines(Pxv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
PxvMean = Pxvstd.error = MeanEFT = vector()

for (i in 1:21){
  PxvMean[i] = mean(c(Pxv[[1]][i], Pxv[[2]][i], Pxv[[3]][i], Pxv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  Pxvstd.error[i] = std.error(c(Pxv[[1]][i], Pxv[[2]][i], Pxv[[3]][i], Pxv[[4]][i]), na.rm=TRUE)
}

CI.up = PxvMean+Pxvstd.error
CI.dn = PxvMean-Pxvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(PxvMean+Pxvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, PxvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression(atop("Produtividade em", "Biomassa " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Instantânea de \n Crescimento referente ao tempo", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```




# produtividade do produto (PRP)
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
PpPRP = cbind((PRPv[[1]]-PRPv[[1]][7])/EFT[[1]], (PRPv[[2]]-PRPv[[2]][7])/EFT[[2]],(PRPv[[3]]-PRPv[[3]][1])/EFT[[3]],(PRPv[[4]]-PRPv[[4]][1])/EFT[[4]])

PpPRP[1,1] = PpPRP[1,2] = PpPRP[1,3] = PpPRP[1,4] = NA

PpPRPv = lapply(1:4, function(i){PpPRP[,i]})

max_y = max(unlist(lapply(PpPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(PpPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], PpPRPv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression(atop("Produtividade de PRP " ~ (g.L^{-1}~h^{-1}))), main = "Produtividade de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(PpPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


```{r}
PpPRPvMean = PpPRPvstd.error = MeanEFT = vector()

for (i in 1:21){
  PpPRPvMean[i] = mean(c(PpPRPv[[1]][i], PpPRPv[[2]][i], PpPRPv[[3]][i], PpPRPv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  PpPRPvstd.error[i] = std.error(c(PpPRPv[[1]][i], PpPRPv[[2]][i], PpPRPv[[3]][i], PpPRPv[[4]][i]), na.rm=TRUE)
}

CI.up = PpPRPvMean+PpPRPvstd.error
CI.dn = PpPRPvMean-PpPRPvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(PpPRPvMean+PpPRPvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, PpPRPvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression(atop("Produtividade de PRP " ~ (g.L^{-1}~h^{-1}))), main = "Produtividade de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(-0.05, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```




# produtividade do produto (Acetato)
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
PpAc = cbind((Acetatov[[1]]-Acetatov[[1]][1])/EFT[[1]], (Acetatov[[2]]-Acetatov[[2]][1])/EFT[[2]],(Acetatov[[3]]-Acetatov[[3]][1])/EFT[[3]],(Acetatov[[4]]-Acetatov[[4]][1])/EFT[[4]])

PpAcv = lapply(1:4, function(i){PpAc[,i]})

max_y = max(unlist(lapply(PpAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(PpAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], PpAcv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression(atop("Produtividade de Acetato " ~ (g.L^{-1}~h^{-1}))), main = "Produtividade de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
#box() # Create box around plot
for (i in 2:4){lines(PpAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
PpAcvMean = PpAcvstd.error = MeanEFT = vector()

for (i in 1:21){
  PpAcvMean[i] = mean(c(PpAcv[[1]][i], PpAcv[[2]][i], PpAcv[[3]][i], PpAcv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  PpAcvstd.error[i] = std.error(c(PpAcv[[1]][i], PpAcv[[2]][i], PpAcv[[3]][i], PpAcv[[4]][i]), na.rm=TRUE)
}

CI.up = PpAcvMean+PpAcvstd.error
CI.dn = PpAcvMean-PpAcvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(PpAcvMean+PpAcvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, PpAcvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab=expression(atop("Produtividade de Acetato " ~ (g.L^{-1}~h^{-1}))), main = "Produtividade de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# velocidades especificas de transformacao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
# velocidades especificas de crescimento
MiX = cbind(rx[,1]/Massav[[1]],rx[,2]/Massav[[2]],rx[,3]/Massav[[3]],rx[,4]/Massav[[4]])

MiXv = lapply(1:4, function(i){MiX[,i]})

max_y = max(unlist(lapply(MiXv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiXv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiXv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Crescimento " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Específica de Crescimento", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(MiXv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("bottomleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
MiXvMean = MiXvstd.error = MeanEFT = vector()

for (i in 1:21){
  MiXvMean[i] = mean(c(MiXv[[1]][i], MiXv[[2]][i], MiXv[[3]][i], MiXv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  MiXvstd.error[i] = std.error(c(MiXv[[1]][i], MiXv[[2]][i], MiXv[[3]][i], MiXv[[4]][i]), na.rm=TRUE)
}

CI.up = MiXvMean+MiXvstd.error
CI.dn = MiXvMean-MiXvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(MiXvMean+MiXvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, MiXvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Crescimento " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Específica de Crescimento", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# velocidades especificas de transformacao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
# velocidades especificas de consumo de substrato
MiS = -1*cbind(rsG[,1]/Massav[[1]],rsG[,2]/Massav[[2]],rsG[,3]/Massav[[3]],rsG[,4]/Massav[[4]])

MiSv = lapply(1:4, function(i){MiS[,i]})

max_y = max(unlist(lapply(MiSv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiSv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiSv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Consumo de Substrato " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Específica de Consumo de Substrato", col = cores[1],  xlim=c(0, xmax), ylim=c(-0.4, 0.4))
#box() # Create box around plot
for (i in 2:4){lines(MiSv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("bottomleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
MiSvMean = MiSvstd.error = MeanEFT = vector()

for (i in 1:21){
  MiSvMean[i] = mean(c(MiSv[[1]][i], MiSv[[2]][i], MiSv[[3]][i], MiSv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  MiSvstd.error[i] = std.error(c(MiSv[[1]][i], MiSv[[2]][i], MiSv[[3]][i], MiSv[[4]][i]), na.rm=TRUE)
}

CI.up = MiSvMean+MiSvstd.error
CI.dn = MiSvMean-MiSvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(MiSvMean+MiSvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, MiSvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Consumo de Substrato " ~ (g.L^{-1}~h^{-1}))), col = 'black',  xlim=c(0, xmax), ylim=c(-2, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```


# velocidades especificas de transformacao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
# velocidades especificas de formacao de produto
MiPAc = cbind(rsAc[,1]/Massav[[1]],rsAc[,2]/Massav[[2]],rsAc[,3]/Massav[[3]],rsAc[,4]/Massav[[4]])

MiPAcv = lapply(1:4, function(i){MiPAc[,i]})

max_y = max(unlist(lapply(MiPAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiPAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiPAcv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Formação de Acetato " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Específica de Formação de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(MiPAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
MiPAcvMean = MiPAcvstd.error = MeanEFT = vector()

for (i in 1:21){
  MiPAcvMean[i] = mean(c(MiPAcv[[1]][i], MiPAcv[[2]][i], MiPAcv[[3]][i], MiPAcv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  MiPAcvstd.error[i] = std.error(c(MiPAcv[[1]][i], MiPAcv[[2]][i], MiPAcv[[3]][i], MiPAcv[[4]][i]), na.rm=TRUE)
}

CI.up = MiPAcvMean+MiPAcvstd.error
CI.dn = MiPAcvMean-MiPAcvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(MiPAcvMean+MiPAcvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, MiPAcvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Formação de Acetato " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Específica de Formação de Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# velocidades especificas de transformacao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
# velocidades especificas de formacao de produto
MiPPRP = cbind(rsPRP[,1]/Massav[[1]],rsPRP[,2]/Massav[[2]],rsPRP[,3]/Massav[[3]],rsPRP[,4]/Massav[[4]])

MiPPRPv = lapply(1:4, function(i){MiPPRP[,i]})

max_y = max(unlist(lapply(MiPPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(MiPPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], MiPPRPv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Espec?fica de","Forma??o de PRP " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Espec?fica de Forma??o de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(MiPPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
MiPPRPvMean = MiPPRPvstd.error = MeanEFT = vector()

for (i in 1:21){
  MiPPRPvMean[i] = mean(c(MiPPRPv[[1]][i], MiPPRPv[[2]][i], MiPPRPv[[3]][i], MiPPRPv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  MiPPRPvstd.error[i] = std.error(c(MiPPRPv[[1]][i], MiPPRPv[[2]][i], MiPPRPv[[3]][i], MiPPRPv[[4]][i]), na.rm=TRUE)
}

CI.up = MiPPRPvMean+MiPPRPvstd.error
CI.dn = MiPPRPvMean-MiPPRPvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(MiPPRPvMean+MiPPRPvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, MiPPRPvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab= expression(atop("Velocidade Específica de","Formação de PRP " ~ (g.L^{-1}~h^{-1}))), main = "Velocidade Específica de Formação de PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(0, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
Yxs = -1*(cbind(DeltaMassa[[1]]/DeltaCGlicose[[1]],DeltaMassa[[2]]/DeltaCGlicose[[2]],DeltaMassa[[3]]/DeltaCGlicose[[3]],DeltaMassa[[4]]/DeltaCGlicose[[4]]))

Yxsv = lapply(1:4, function(i){Yxs[,i]})

max_y = max(unlist(lapply(Yxsv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(Yxsv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], Yxsv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Biomassa/Glicose", main = "Coeficiente Específico de Biomassa/Glicose", col = cores[1],  xlim=c(1, xmax), ylim=c(-10, max_y))
#box() # Create box around plot
for (i in 2:4){lines(Yxsv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
YxsvMean = Yxsvstd.error = MeanEFT = vector()

for (i in 1:21){
  YxsvMean[i] = mean(c(Yxsv[[1]][i], Yxsv[[2]][i], Yxsv[[3]][i], Yxsv[[4]][i]), na.rm=TRUE)
}

YxsvMean[1] = YxsvMean[17] = NA

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  Yxsvstd.error[i] = std.error(c(Yxsv[[1]][i], Yxsv[[2]][i], Yxsv[[3]][i], Yxsv[[4]][i]), na.rm=TRUE)
}

CI.up = YxsvMean+Yxsvstd.error
CI.dn = YxsvMean-Yxsvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(YxsvMean+Yxsvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, YxsvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Biomassa/Glicose", col = 'black',  xlim=c(0, xmax), ylim=c(-50, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# Fatores de conversao e os coeficientes especificos de manutencao
```{r}
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
YxpAc = cbind(DeltaMassa[[1]]/DeltaAcetato[[1]],DeltaMassa[[2]]/DeltaAcetato[[2]],DeltaMassa[[3]]/DeltaAcetato[[3]],DeltaMassa[[4]]/DeltaAcetato[[4]])

YxpAcv = lapply(1:4, function(i){YxpAc[,i]})

max_y = max(unlist(lapply(YxpAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YxpAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YxpAcv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Biomassa/Acetato", main = "Coeficiente Específico de Biomassa/Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(YxpAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("bottomright", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


```{r}
YxpAcvMean = YxpAcvstd.error = MeanEFT = vector()

for (i in 1:21){
  YxpAcvMean[i] = mean(c(YxpAcv[[1]][i], YxpAcv[[2]][i], YxpAcv[[3]][i], YxpAcv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  YxpAcvstd.error[i] = std.error(c(YxpAcv[[1]][i], YxpAcv[[2]][i], YxpAcv[[3]][i], YxpAcv[[4]][i]), na.rm=TRUE)
}

CI.up = YxpAcvMean+YxpAcvstd.error
CI.dn = YxpAcvMean-YxpAcvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(YxpAcvMean+YxpAcvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, YxpAcvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Biomassa/Acetato", main = "Coeficiente Específico de Biomassa/Acetato", col = cores[1],  xlim=c(0, xmax), ylim=c(-10, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```

# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
YxpPRP = cbind(DeltaMassa[[1]]/DeltaPRP[[1]],DeltaMassa[[2]]/DeltaPRP[[2]],DeltaMassa[[3]]/DeltaPRP[[3]],DeltaMassa[[4]]/DeltaPRP[[4]])

YxpPRPv = lapply(1:4, function(i){YxpPRP[,i]})

max_y = max(unlist(lapply(YxpPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YxpPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YxpPRPv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Espec?fico \n de Biomassa/PRP", main = "Coeficiente Espec?fico de Biomassa/PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(min_y, max_y))
#box() # Create box around plot
for (i in 2:4){lines(YxpPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
YxpPRPvMean = YxpPRPvstd.error = MeanEFT = vector()

for (i in 1:21){
  YxpPRPvMean[i] = mean(c(YxpPRPv[[1]][i], YxpPRPv[[2]][i], YxpPRPv[[3]][i], YxpPRPv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  YxpPRPvstd.error[i] = std.error(c(YxpPRPv[[1]][i], YxpPRPv[[2]][i], YxpPRPv[[3]][i], YxpPRPv[[4]][i]), na.rm=TRUE)
}

CI.up = YxpPRPvMean+YxpPRPvstd.error
CI.dn = YxpPRPvMean-YxpPRPvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(YxpPRPvMean+YxpPRPvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, YxpPRPvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Biomassa/PRP", main = "Coeficiente Específico de Biomassa/PRP", col = cores[1],  xlim=c(0, xmax), ylim=c(-150, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```




# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
YpsAc = -1*(cbind(DeltaAcetato[[1]]/DeltaCGlicose[[1]],DeltaAcetato[[2]]/DeltaCGlicose[[2]],DeltaAcetato[[3]]/DeltaCGlicose[[3]],DeltaAcetato[[4]]/DeltaCGlicose[[4]]))

YpsAcv = lapply(1:4, function(i){YpsAc[,i]})

max_y = max(unlist(lapply(YpsAcv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YpsAcv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YpsAcv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Acetato/Glicose", main = "Coeficiente Específico de Acetato/Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(-10, 10))
#box() # Create box around plot
for (i in 2:4){lines(YpsAcv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("bottomleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```


```{r}
YpsAcvMean = YpsAcvstd.error = MeanEFT = vector()

for (i in 1:21){
  YpsAcvMean[i] = mean(c(YpsAcv[[1]][i], YpsAcv[[2]][i], YpsAcv[[3]][i], YpsAcv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  YpsAcvstd.error[i] = std.error(c(YpsAcv[[1]][i], YpsAcv[[2]][i], YpsAcv[[3]][i], YpsAcv[[4]][i]), na.rm=TRUE)
}

CI.up = YpsAcvMean+YpsAcvstd.error
CI.dn = YpsAcvMean-YpsAcvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(YpsAcvMean+YpsAcvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, YpsAcvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de Acetato/Glicose", col = 'black',  xlim=c(0, xmax), ylim=c(-10, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```



# Fatores de conversao e os coeficientes especfficos de manutencao
```{r}
# se Yxs, Yxp ou Yps nao forem constantes, entao somente seus valores instantaneos deverao ser levados em conta
par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
YpsPRP = -1*(cbind(DeltaPRP[[1]]/DeltaCGlicose[[1]],DeltaPRP[[2]]/DeltaCGlicose[[2]],DeltaPRP[[3]]/DeltaCGlicose[[3]],DeltaPRP[[4]]/DeltaCGlicose[[4]]))

YpsPRPv = lapply(1:4, function(i){YpsPRP[,i]})

max_y = max(unlist(lapply(YpsPRPv,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
min_y = min(unlist(lapply(YpsPRPv,FUN=min,na.rm=TRUE))) # Compute the minor y value used in the data
plot(EFTv[[1]], YpsPRPv[[1]], type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de PRP/Glicose", main = "Coeficiente Específico de PRP/Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(-2, 2))
#box() # Create box around plot
for (i in 2:4){lines(YpsPRPv[[i]], type="o", pch=20+i, lty = i, col=cores[i])}
legend("topleft", max_y, legend = c("HibPP0616", "HibPP0716", "HibPP0816", "HibPP0217"), cex=0.7, col=c(cores[1], cores[2], cores[3], cores[4]), pch=21:24, lty=1:4)
```

```{r}
YpsPRPvMean = YpsPRPvstd.error = MeanEFT = vector()

for (i in 1:21){
  YpsPRPvMean[i] = mean(c(YpsPRPv[[1]][i], YpsPRPv[[2]][i], YpsPRPv[[3]][i], YpsPRPv[[4]][i]), na.rm=TRUE)
}

for (i in 1:21){
  MeanEFT[i] = mean(c(EFTv[[1]][i], EFTv[[2]][i], EFTv[[3]][i], EFTv[[4]][i]))
}

for (i in 1:21){
  YpsPRPvstd.error[i] = std.error(c(YpsPRPv[[1]][i], YpsPRPv[[2]][i], YpsPRPv[[3]][i], YpsPRPv[[4]][i]), na.rm=TRUE)
}

CI.up = YpsPRPvMean+YpsPRPvstd.error
CI.dn = YpsPRPvMean-YpsPRPvstd.error

par(mar=c(6,6,3,3),cex.axis=1.5,cex.lab=1.2)
max_y = max(unlist(lapply(YpsPRPvMean+YpsPRPvstd.error,FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data
plot(MeanEFT, YpsPRPvMean, type="o", pch=21, lty = 1, xlab="Tempo (h)", ylab="Coeficiente Específico \n de PRP/Glicose", main = "Coeficiente Específico de PRP/Glicose", col = cores[1],  xlim=c(0, xmax), ylim=c(-4, max_y))
arrows(MeanEFT,CI.dn,MeanEFT,CI.up,code=3,length=0.1,angle=90,col='black')
```


# M?dia dos dados dos cultivos
```{r}

Dados = vector(mode = "list", length = 4)
for (i in 1:4) {Dados[[i]] <- cbind(EFTv[[i]], Massav[[i]], Acetatov[[i]], Glicosev[[i]], PRPv[[i]], CO2v[[i]], O2v[[i]], rxv[[i]], rsGv[[i]], rsPRPv[[i]], rsAcv[[i]], Pxv[[i]], PpAcv[[i]], PpPRPv[[i]], MiXv[[i]], MiSv[[i]], MiPAcv[[i]], MiPPRPv[[i]], Yxs[[i]], YxpAcv[[i]], YxpPRPv[[i]], YpsAcv[[i]], YpsPRPv[[i]], MMv[[i]], CGlicosev[[i]])}

# une todos os dados em arranjo
arrayDados = array(c(Dados[[1]],Dados[[2]],Dados[[3]], Dados[[4]]), dim=c(nrow(Dados[[1]]),ncol(Dados[[1]]),4))
# m?dia dos dados
Mean = apply(arrayDados, c(1,2), mean, na.rm=TRUE)

colnames(Mean) = c("Tempo (h)", "Massa Seca", "[Acetato]", "[Glicose]", "[PRP]", "[CO2]", "[O2]", "Crescimento Especifico", "velocidade Instantanea de Consumo de Substrato", "Velocidade Instantanea de Formacao de PRP", "Velocidade Instantanea de Formacao de Acetato", "Velocidade Instantanea de Crescimento referente ao tempo", "Produtividade de PRP", "Produtividade de Acetato", "Velocidade Especifica de Crescimento", "Velocidade Especifica de Consumo de Substrato", "Velocidade Especifica de Formacao de Acetato", "Velocidade Especifica de Formacao de PRP", "Coeficiente Especifico de Biomassa/Glicose", "Coeficiente Especifico de Biomassa/Acetato", "Coeficiente Especifico de Biomassa/PRP", "Coeficiente Especifico de Acetato/Glicose", "Coeficiente Especifico de PRP/Glicose", "Massa Molecular", "Concentracao de Glicose Consumida")

rownames(Mean) = sapply(0:21, function(i){paste0(i, "h")})
```





# Plot da m?dia dos dados
```{r, fig.width=7, fig.height=7}
##par(mar=c(6,6,3,3)+7,cex.axis=1.5,cex.lab=1.2)
par(mar=c(5, 12, 4, 12) + 0.1,cex.axis=1.5,cex.lab=1.2)
cores = c("black", "cyan", "purple", "green", "blue", "red", "darkgoldenrod")

xmax = max(unlist(lapply(Mean[,1],FUN=max,na.rm=TRUE)))
max_y = max(unlist(lapply(Mean[,2],FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data

# Massa Seca vs tempo
plot(Mean[,1], Mean[,2], axes=F, ylim=c(0,max_y+2), xlab="", ylab="",type="o",col="black", main="",xlim=c(0,xmax), lty = 2)
points(Mean[,1],Mean[,2],pch=4,col=cores[1])
axis(2, ylim=c(0,max_y),col=cores[1],lwd=2)
mtext(2,text=expression("[Biomass] " ~ (g.L^{-1})),line=2, cex=1.5) #line controls the distance from the plot area.

# insert axes

# Acetato
par(new=T)
max_y3 = max(unlist(lapply(Mean[,3],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,3], axes=F, ylim=c(0,max_y3), xlab="", ylab="", type="o", col=cores[3], main="",xlim=c(0,xmax),lwd=2, lty = 3)
axis(2, ylim=c(0,max_y3),lwd=2,line=4,col=cores[3])
points(Mean[,1], Mean[,3],pch=5)
mtext(2,text=expression("[Acetate] " ~ (g.L^{-1})),line=6, cex=1.5)

# Glicose
par(new=T)
max_y4 = max(unlist(lapply(Mean[,4],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,4], axes=F, ylim=c(0,max_y4+1), xlab="", ylab="", type="o", col=cores[4], main="",xlim=c(0,xmax),lwd=2, lty = 4)
axis(2, ylim=c(0,max_y4),lwd=2,line=8,col=cores[4])
points(Mean[,1], Mean[,4],pch=2)
mtext(2,text=expression("[Glucose] " ~ (g.L^{-1})),line=10, cex=1.5)

# PRP
par(new=T)
max_y5 = max(unlist(lapply(Mean[,5],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,5], axes=F, ylim=c(0,max_y5), xlab="", ylab="", type="o", col=cores[5], main="",xlim=c(0,xmax),lwd=2, lty = 5)
axis(side=4, at = c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4), labels = format(c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4), decimal.mark=","), ylim=c(0,max_y5),lwd=2,line=0,col=cores[5])
points(Mean[,1], Mean[,5],pch=11)
mtext(4,text=expression("[PRP] " ~ (g.L^{-1})),line=2.7, cex=1.5)

# CO2
par(new=T)
max_y6 = max(unlist(lapply(Mean[,6],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,6], axes=F, ylim=c(0,max_y6), xlab="", ylab="", type="o", col=cores[6], main="",xlim=c(0,xmax),lwd=2, lty = 6)
axis(4, ylim=c(0,max_y6),lwd=2,line=4,col=cores[6])
points(Mean[,1], Mean[,6],pch=1)
mtext(4,text=expression("[" ~ CO[2] ~ "] (%)"),line=6, cex=1.5)

# O2
# par(new=T)
# max_y7 = max(unlist(lapply(Mean[,7],FUN=max,na.rm=TRUE)))
# plot(Mean[,1], Mean[,7], axes=F, ylim=c(0,max_y7+20), xlab="", ylab="", type="o", col=cores[7], main="",xlim=c(0,xmax),lwd=2, lty = 7)
# axis(4, ylim=c(0,max_y7),lwd=2,line=6.5,col=cores[7])
# points(Mean[,1], Mean[,7],pch=0)
# mtext(4,text=expression("[" ~ O[2] ~ "] (%)"),line=8.5)

axis(1,ylim=c(0,22), line=0)
mtext("Time (h)",side=1,col="black",line=2.2, cex=1.5)

#box(lty = '1', col = 'black')


# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots

# legend("bottomright", xmax, ncol=2, legend = c(expression("[Biomassa Seca] " ~ (g.L^{-1})), expression("[Acetato] " ~ (g.L^{-1})), expression("[Glicose] " ~ (g.L^{-1})), expression("[PRP] " ~ (g.L^{-1})), expression("[" ~ CO[2] ~ "] (%)"), expression("[" ~ O[2] ~ "] (%)")), col=c(cores[1], cores[3], cores[4], cores[5], cores[6], cores[7]),cex=0.15, pch=c(4,5,2,11,1,0), lty=2:7, box.lwd=1)
# add axis for each data trait
```

# Plot da m?dia dos dados
```{r, fig.width=7, fig.height=7}
##par(mar=c(6,6,3,3)+7,cex.axis=1.5,cex.lab=1.2)
# "Crescimento Especifico", "velocidade Instantanea de Consumo de Substrato", "Velocidade Instantanea de Formacao de PRP", "Velocidade Instantanea de Formacao de Acetato", "Velocidade Instantanea de Crescimento referente ao tempo", "Produtividade de PRP", "Produtividade de Acetato",
par(mar=c(5, 12, 4, 12) + 0.1,cex.axis=1.5,cex.lab=1.2)
cores = c("black", "cyan", "purple", "green", "blue", "red", "darkgoldenrod")

xmax = max(unlist(lapply(Mean[,1],FUN=max,na.rm=TRUE)))
max_y = max(unlist(lapply(Mean[,8],FUN=max,na.rm=TRUE))) # Compute the largest y value used in the data

# # "Crescimento Especifico"
# plot(Mean[,1], Mean[,8], axes=F, ylim=c(0,max_y), xlab="", ylab="",type="o",col="black", main="",xlim=c(0,xmax), lty = 2)
# points(Mean[,1],Mean[,8],pch=4,col=cores[1])
# axis(2, at = c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4), labels = format(c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4), decimal.mark=","), ylim=c(0,max_y),lwd=2, col=cores[1])
# mtext(2,text="Crescimento Especifico",line=2) #line controls the distance from the plot area.

# insert axes

# "Concentracao de Glicose Consumida"
par(new=T)
max_y25 = max(unlist(lapply(Mean[,25],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,25], axes=F, ylim=c(0,max_y25+1), xlab="", ylab="", type="o", col=cores[7], main="",xlim=c(0,xmax),lwd=2, lty = 25)
axis(2, at = c(0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0), labels = format(c(0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0), decimal.mark=","), ylim=c(0,max_y25),lwd=2,line=3.5, col=cores[7])
points(Mean[,1], Mean[,25],pch=0)
mtext(2,text=expression("[Glicose Consumida] " ~ (g.L^{-1})),line=5.5)

# Produtividade de PRP
par(new=T)
max_y13 = max(unlist(lapply(Mean[,13],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,13], axes=F, ylim=c(0,max_y13+0.2), xlab="", ylab="", type="o", col=cores[5], main="",xlim=c(0,xmax),lwd=2, lty = 13)
axis(4, at = c(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6), labels = format(c(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)),ylim=c(0,max_y13),lwd=2,line=0, col=cores[5])
points(Mean[,1], Mean[,13],pch=1)
mtext(4,text=expression("Produtividade de PRP " ~ (g.L^{-1})),line=2)

# Produtividade de Acetato
par(new=T)
max_y14 = max(unlist(lapply(Mean[,14],FUN=max,na.rm=TRUE)))
plot(Mean[,1], Mean[,14], axes=F, ylim=c(0,max_y14+0.02), xlab="", ylab="", type="o", col=cores[4], main="",xlim=c(0,xmax),lwd=2, lty = 14)
axis(4, at = c(0.00, 0.02, 0.04, 0.06, 0.08), labels = format(c(0.00, 0.02, 0.04, 0.06, 0.08)),ylim=c(0,max_y14),lwd=2,line=3.5, col=cores[4])
points(Mean[,1], Mean[,14],pch=2)
mtext(4,text=expression("Produtividade de Acetato " ~ (g.L^{-1})),line=5.5)

axis(1,xlim=c(0,xmax+1), line=0)
mtext("Tempo (h)",side=1,col="black",line=2)



# Create a legend at (1, max_y) that is slightly smaller (cex) and uses the same line colors and points used by the actual plots

# legend("bottomright", xmax, legend = c("Crescimento espec?fico", expression("[Glicose Consumida] " ~ (g.L^{-1})), expression("Produtividade de PRP " ~ (g.L^{-1})), expression("Produtividade de Acetato " ~ (g.L^{-1}))), col=c(cores[1], cores[7], cores[5], cores[4]),cex=0.2,  pt.cex = 1, pch=c(4, 0, 1, 2), lty=c(2,25,13,14), box.lwd=1)
# add axis for each data trait
```


# Dados
```{r}
sDados = vector(mode = "list", length = 24)
sDados[[1]] = cbind(Massas[[1]], Massas[[2]], Massas[[3]], Massas[[4]])
sDados[[2]] = cbind(Acetatos[[1]], Acetatos[[2]], Acetatos[[3]], Acetatos[[4]])
sDados[[3]] = cbind(Glicoses[[1]], Glicoses[[2]], Glicoses[[3]], Glicoses[[4]])
sDados[[4]] = cbind(PRPs[[1]], PRPs[[2]], PRPs[[3]], PRPs[[4]])
sDados[[5]] = cbind(CO2s[[1]],CO2s[[2]], CO2s[[3]], CO2s[[4]])
sDados[[6]] = cbind(O2s[[1]], O2s[[2]], O2s[[3]], O2s[[4]])
sDados[[7]] = cbind(rx[,1][points], rx[,2][points], rx[,3][points], rx[,4][points])
sDados[[8]] = cbind(rsG[,1][points], rsG[,2][points], rsG[,3][points], rsG[,4][points])
sDados[[9]] = cbind(rsPRP[,1][points], rsPRP[,2][points], rsPRP[,3][points], rsPRP[,4][points])
sDados[[10]] = cbind(rsAc[,1][points], rsAc[,2][points], rsAc[,3][points], rsAc[,4][points])
sDados[[11]] = cbind(Px[,1][points], Px[,2][points], Px[,3][points], Px[,4][points])
sDados[[12]] = cbind(PpAc[,1][points], PpAc[,2][points], PpAc[,3][points], PpAc[,4][points])
sDados[[13]] = cbind(PpPRP[,1][points], PpPRP[,2][points], PpPRP[,3][points], PpPRP[,4][points])
sDados[[14]] = cbind(MiX[,1][points], MiX[,2][points], MiX[,3][points], MiX[,4][points])
sDados[[15]] = cbind(MiS[,1][points], MiS[,2][points], MiS[,3][points], MiS[,4][points])
sDados[[16]] = cbind(MiPAc[,1][points], MiPAc[,2][points], MiPAc[,3][points], MiPAc[,4][points])
sDados[[17]] = cbind(MiPPRP[,1][points], MiPPRP[,2][points], MiPPRP[,3][points], MiPPRP[,4][points])
sDados[[18]] = cbind(Yxs[,1][points], Yxs[,2][points], Yxs[,3][points], Yxs[,4][points])
sDados[[19]] = cbind(YxpAc[,1][points], YxpAc[,2][points], YxpAc[,3][points], YxpAc[,4][points])
sDados[[20]] = cbind(YxpPRP[,1][points], YxpPRP[,2][points], YxpPRP[,3][points], YxpPRP[,4][points])
sDados[[21]] = cbind(YpsAc[,1][points], YpsAc[,2][points], YpsAc[,3][points], YpsAc[,4][points])
sDados[[22]] = cbind(YpsPRP[,1][points], YpsPRP[,2][points], YpsPRP[,3][points], YpsPRP[,4][points])
sDados[[23]] = cbind(MMs[[1]], MMs[[2]], MMs[[3]], MMs[[4]])
sDados[[24]] = cbind(CGlicoses[[1]], CGlicoses[[2]], CGlicoses[[3]], CGlicoses[[4]])
```

# tDados
```{r}
tDados = vector(mode = "list", length = length(sDados))
for (i in 1:length(sDados)){tDados[[i]] = append(sDados[[i]][1,], unlist(lapply(2:6, function(j){sDados[[i]][j,]})))} # Samples data traits

names(tDados) = c("Massa Seca", "[Acetato]", "[Glicose]", "[PRP]", "[CO2]", "[O2]", "Crescimento Especifico", "velocidade Instantanea de Consumo de Substrato", "Velocidade Instantanea de Formacao de PRP", "Velocidade Instantanea de Formacao de Acetato", "Velocidade Instantanea de Crescimento referente ao tempo", "Produtividade de PRP", "Produtividade de Acetato", "Velocidade Especifica de Crescimento", "Velocidade Especifica de Consumo de Substrato", "Velocidade Especifica de Formacao de Acetato", "Velocidade Especifica de Formacao de PRP", "Coeficiente Especifico de Biomassa/Glicose", "Coeficiente Especifico de Biomassa/Acetato", "Coeficiente Especifico de Biomassa/PRP", "Coeficiente Especifico de Acetato/Glicose", "Coeficiente Especifico de PRP/Glicose", "Massa Molecular", "Concentracao de Glicose Consumida")
```

# Pairwise scatter plots of the samples (arrays) along the module eigengenes
# Produtividade de PRP
```{r, fig.width=7, fig.height=7}
# The function plotMEpairs() produces a matrix of plots containing pairwise scatterplots of given eigengenes, the distribution of their values and their pairwise correlations.
# The function plotMEpairs() produces an NxN matrix of plots, where N is the number of eigengenes. 
# In the upper triangle it plots pairwise scatterplots of module eigengenes (plus the trait y, if given).
# On the diagonal it plots histograms of sample values for each eigengene. 
# Below the diagonal, it displays the pairwise correlations of the eigengenes
# datME is a data frame containing expression data, with rows corresponding to samples and columns to genes. Missing values are allowed and will be ignored.
# y is an optional sample trait vector. It will be treated as an additional eigengene.
# clusterMEs -> logical: should the module eigengenes be ordered by their dendrogram?
datME %>% plotMEpairs(y=tDados[[13]], clusterMEs = TRUE)
```


# Finding modules that relate to a data trait

# Measure of module significance as average gene significance
```{r}
# The advantage of this second approach is that it can be used for any gene significance measure
# define a measure of module significance as the average gene significance of all genes in the module
# use the absolute value for defining a correlation based gene significance measure
GS = GeneSignificance = vector(mode = "list", length = length(tDados))
for (i in 1:length(tDados)){GS[[i]]=as.numeric(cor(tDados[[i]],datExpr, use="p"))}
for (i in 1:length(tDados)){GeneSignificance[[i]]=abs(GS[[i]])}
for (i in 1:length(GeneSignificance)){names(GeneSignificance[[i]]) = names(datExpr0)}

# Next module significance is defined as average gene significance.
ModuleSignificance = vector(mode = "list", length = length(tDados))
for (i in 1:length(tDados)){ModuleSignificance[[i]]=tapply(GeneSignificance[[i]], moduleColors, mean, na.rm=T)}
```

# To plot module significance
```{r, fig.width=7, fig.height=7}
plotModuleSignificance(GeneSignificance[[13]],moduleColors)
```


# Visualizing the network of eigengenes vs Traits
```{r, fig.width=7, fig.height=7}
#MET = list()
#for (i in 1:length(tDados)){MET[[i]] = orderMEs(cbind(MEs, tDados[[i]]))}
MET = orderMEs(cbind(MEs, Massa_Molecular = tDados$`Massa Molecular`))

# Plot the relationships among the eigengenes and the trait

par(cex = 1.0)
plotEigengeneNetworks(MET, "Eigengene dendrogram", marDendro = c(0,4,2,0),
plotHeatmaps = FALSE)
par(cex = 1.0)
plotEigengeneNetworks(MET, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2), cex.lab = 0.8, xLabelsAngle = 90)
```






# Module-trait relationships
```{r, fig.width=24, fig.height=14}

nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

datTraits = data.frame("Massa Seca" = tDados$`Massa Seca`, "[Acetato]" = tDados$`[Acetato]`, "[Glicose]" = tDados$`[Glicose]`, "[Glicose Consumida]" = tDados$`Concentracao de Glicose Consumida`, "[PRP]" = tDados$`[PRP]`, "[CO2]" = tDados$`[CO2]`, "Crescimento Especifico" = tDados$`Crescimento Especifico`, "Velocidade Instantanea de Consumo de Substrato" = tDados$`velocidade Instantanea de Consumo de Substrato`, "Velocidade Instantanea de Formacao de PRP" = tDados$`Velocidade Instantanea de Formacao de PRP`, "Velocidade Instantanea de Formacao de Acetato" = tDados$`Velocidade Instantanea de Formacao de Acetato`, "Velocidade Instantanea de Crescimento referente ao tempo" = tDados$`Velocidade Instantanea de Crescimento referente ao tempo`, "Produtividade de PRP" = tDados$`Produtividade de PRP`, "Produtividade de Acetato" = tDados$`Produtividade de Acetato`, "Velocidade Especifica de Crescimento" = tDados$`Velocidade Especifica de Crescimento`, "Velocidade Especifica de Consumo de Substrato" = tDados$`Velocidade Especifica de Consumo de Substrato`, "Velocidade Especifica de Formacao de Acetato" = tDados$`Velocidade Especifica de Formacao de Acetato`, "Velocidade Especifica de Formacao de PRP" = tDados$`Velocidade Especifica de Formacao de PRP`, "Coeficiente Especifico de Biomassa-Glicose" = tDados$`Coeficiente Especifico de Biomassa/Glicose`, "Coeficiente Especifico de Biomassa-Acetato" = tDados$`Coeficiente Especifico de Biomassa/Acetato`, "Coeficiente Especifico de Biomassa-PRP" = tDados$`Coeficiente Especifico de Biomassa/PRP`,"Coeficiente Especifico de Acetato-Glicose" = tDados$`Coeficiente Especifico de Acetato/Glicose`, "Coeficiente Especifico de PRP-Glicose" = tDados$`Coeficiente Especifico de PRP/Glicose`, "Massa Molecular" = tDados$`Massa Molecular`)

datTraits[datTraits == -Inf] <- NA

moduleTraitCor = cor(MEs, datTraits, use = "pairwise.complete.obs")

moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)

#a suitable graphical representation will help in reading the table
# We color code each association by the correlation value
# Will display correlations and their p-values

textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")

xL=c("[Biomassa]", "[Acetato]", "[Glicose]", "[Glicose Consumida]", "[PRP]", "[CO2]", "Crescimento Especifico", "Velocidade Instantanea de Consumo de Substrato", "Velocidade Instantanea de Formacao de PRP", "Velocidade Instantanea de Formacao de Acetato", "Velocidade Instantanea de Crescimento referente ao tempo", "Produtividade de PRP", "Produtividade de Acetato", "Velocidade Especifica de Crescimento", "Velocidade Especifica de Consumo de Substrato", "Velocidade Especifica de Formacao de Acetato", "Velocidade Especifica de Formacao de PRP", "Coeficiente Especifico de Biomassa-Glicose", "Coeficiente Especifico de Biomassa-Acetato", "Coeficiente Especifico de Biomassa-PRP", "Coeficiente Especifico de Acetato-Glicose", "Coeficiente Especifico de PRP-Glicose", "Massa Molecular")
#par(mar = c(12, 5, 4, 2)+ 0.1)
par(mar = c(6, 8.8, 3, 2.2)+2)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = xL, yLabels = names(MEs), ySymbols = names(MEs), colorLabels = FALSE, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = FALSE, cex.text = 0.6, zlim = c(-1,1), main = paste("Relaçõees módulos-dados dos cultivos"), xLabelsAngle = 90)
```



# Intramodular Connectivity
```{r}
# Calculates intramodular connectivity, i.e., connectivity of nodes to other nodes within the same module

# Returns a data frame with 4 columns giving:
# kTotal = the total connectivity, 
# kWithin = intramodular connectivity,
# kOut = extra-modular connectivity, and 
# kDiff = the difference of the intra and extra-modular connectivities for all genes

Alldegrees=intramodularConnectivity(adjacency, moduleColors)
head(Alldegrees)





brownmodule = Alldegrees$kWithin[(moduleColors==which.module[[1]])]
names(brownmodule) = rownames(moduleblocks[[1]])
sort(brownmodule, decreasing=TRUE)

blackmodule = Alldegrees$kWithin[(moduleColors==which.module[[2]])]
names(blackmodule) = rownames(moduleblocks[[2]])
sort(blackmodule, decreasing=TRUE)

purplemodule = Alldegrees$kWithin[(moduleColors==which.module[[3]])]
names(purplemodule) = rownames(moduleblocks[[3]])
sort(purplemodule, decreasing=TRUE)

bluemodule = Alldegrees$kWithin[(moduleColors==which.module[[4]])]
names(bluemodule) = rownames(moduleblocks[[4]])
sort(bluemodule, decreasing=TRUE)

redmodule = Alldegrees$kWithin[(moduleColors==which.module[[5]])]
names(redmodule) = rownames(moduleblocks[[5]])
sort(redmodule, decreasing=TRUE)

magentamodule = Alldegrees$kWithin[(moduleColors==which.module[[6]])]
names(magentamodule) = rownames(moduleblocks[[6]])
sort(magentamodule, decreasing=TRUE)

greenmodule = Alldegrees$kWithin[(moduleColors==which.module[[7]])]
names(greenmodule) = rownames(moduleblocks[[7]])
sort(greenmodule, decreasing=TRUE)

pinkmodule = Alldegrees$kWithin[(moduleColors==which.module[[8]])]
names(pinkmodule) = rownames(moduleblocks[[8]])
sort(pinkmodule, decreasing=TRUE)
```

# Intramodular analysis: Relationship between gene significance (PRP productivity) and intramodular connectivity
```{r, fig.width=10, fig.height=10}
# : Gene significance (y-axis) vs. intramodular connectivity (x-axis) plotted separately for each module in the simulated data set. For the brown, purple, blue and red module we observe that intramodular hub genes tend to have high gene significance. 


colorlevels=unique(which.module)
par(mfrow=c(3,3))
par(mar = c(4,5,3,1))
for (i in c(1:length(colorlevels))){
whichmodule=which.module[[i]];
restrict1 = (moduleColors==whichmodule);
verboseScatterplot(Alldegrees$kWithin[restrict1],
GeneSignificance[[13]][restrict1], col=moduleColors[restrict1],
main=whichmodule,
xlab = "Connectividade", ylab = "Importância do Gene", abline = TRUE, cex.lab=1.5, cex.axis = 1.5)
}
```

# Intramodular analysis: Relationship between gene significance (Acetate productivity) and intramodular connectivity
```{r, fig.width=14, fig.height=14}
# : Gene significance (y-axis) vs. intramodular connectivity (x-axis) plotted separately for each module in the simulated data set. For the brown, purple, blue and red module we observe that intramodular hub genes tend to have high gene significance. 


colorlevels=unique(which.module)
par(mfrow=c(3,3))
par(mar = c(4,5,3,1))
for (i in c(1:length(colorlevels))){
whichmodule=which.module[[i]];
restrict1 = (moduleColors==whichmodule);
verboseScatterplot(Alldegrees$kWithin[restrict1],
GeneSignificance[[12]][restrict1], col=moduleColors[restrict1],
main=whichmodule,
xlab = "Connectividade", ylab = "Importância do Gene", abline = TRUE, cex.lab=1.5, cex.axis = 1.5)
}
```





# Generalizing intramodular connectivity for all genes
```{r}
# The intramodular connectivity measure is only defined for the genes inside a given module. 
# But in practice it can be very important to measure how connected a given genes is to biologically interesting modules
# We define a module eigengene-based connectivity measure for each gene as the correlation between a the gene expression and the module eigengene

# We have a module membership value for each gene in each module
datKME=signedKME(datExpr, datME, outputColumnName="MM.")
head(datKME)
```

# Finding genes with high gene significance and high intramodular connectivity in interesting modules
```{r}
# Our previous analysis has shown that the blue module is an "interesting"module in that its module significance is high
FilterGenes= abs(GeneSignificance[[13]])> .2 & abs(datKME$MM.blue)>.8
table(FilterGenes)

# Which genes were filtered in?
dimnames(data.frame(datExpr))[[2]][FilterGenes]

```

# Intramodular analysis: identifying genes with high GS and MM
```{r, fig.width=7, fig.height=7}

module = which.module[[5]]

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

geneTraitSignificance = as.data.frame(cor(datExpr, datTraits, use = "p"))

moduleGenes = moduleColors==module

modNames = substring(names(MEs), 3)

column = match(module, modNames)

par(mfrow = c(2,2))

verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]), abs(geneTraitSignificance[moduleGenes, 13]), xlab = paste("Associacao a modulo no modulo", module), ylab = "Significancia de Gene \n para Produtividade de PRP", main = paste("Associacao a modulo vs. significancia de gene\n"), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)

verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]), abs(geneTraitSignificance[moduleGenes, 14]), xlab = paste("Associacao a modulo no modulo", module), ylab = "Significancia de Gene \n para Produtividade de Acetato", main = paste("Associacao a modulo vs. significancia de gene\n"), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)

verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]), abs(geneTraitSignificance[moduleGenes, 5]), xlab = paste("Associacao a modulo no modulo", module), ylab = "Significancia de Gene \n para Concentracao de PRP", main = paste("Associacao a modulo vs. significancia de gene\n"), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)

verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]), abs(geneTraitSignificance[moduleGenes, 2]), xlab = paste("Associacao a modulo no modulo", module), ylab = "Significancia de Gene \n para Concentracao de Acetato", main = paste("Associacao a modulo vs. significancia de gene\n"), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```

# Diagnostics: displaying acetate production genes line plots
```{r, fig.width=7, fig.height=7}
par(mfrow=c(1,2), mar=c(5, 4.2, 3, 0.7), cex.axis=1.5,cex.lab=1.2)

GeneSignificance[[12]]["HIB_14020"]
GeneSignificance[[12]]["HIB_13620"]

boxplot(WGCNAtpm[c("HIB_14020"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_14020", at =c(1, 3, 5, 7, 9, 11), col=which.module[[3]])
boxplot(WGCNAtpm[c("HIB_13620"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_13620", at =c(1, 3, 5, 7, 9, 11), col=which.module[[4]])

# min_y = min(WGCNAtpm)
# max_y = max(max(WGCNAtpm["HIB_14020",]), max(WGCNAtpm["HIB_13620",]))

# plot(1:24, WGCNAtpm["HIB_14020",], col=which.module[[3]], type="l", main="", cex.main=2, ylab="Express?o do gene", cex.lab = 1.5, xlim=c(1,24), xlab="", ylim=c(min_y, max_y), xaxt='n')
# axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
# lines(1:24, WGCNAtpm["HIB_13620",], col=which.module[[4]])
# legend("bottomright", lty=1, legend=c(expression(italic("hib_14020")), expression(italic("hib_13620"))), cex=0.5, col=c(which.module[[3]], which.module[[4]]))
```


# Diagnostics: Interesting genes
```{r, fig.width=7, fig.height=7}
library("plotrix")

GeneMean = Genesd = Genestd.error = CI.up = CI.dn = list()

GeneMean[[1]] = rbind(mean(WGCNAtpm[c("HIB_14020"),1:4]), mean(WGCNAtpm[c("HIB_14020"),5:8]), mean(WGCNAtpm[c("HIB_14020"),9:12]), mean(WGCNAtpm[c("HIB_14020"),13:16]), mean(WGCNAtpm[c("HIB_14020"),17:20]),  mean(WGCNAtpm[c("HIB_14020"),21:24]))

GeneMean[[2]] = rbind(mean(WGCNAtpm[c("HIB_13620"),1:4]), mean(WGCNAtpm[c("HIB_13620"),5:8]), mean(WGCNAtpm[c("HIB_13620"),9:12]), mean(WGCNAtpm[c("HIB_13620"),13:16]), mean(WGCNAtpm[c("HIB_13620"),17:20]),  mean(WGCNAtpm[c("HIB_13620"),21:24]))

GeneMean[[3]] = rbind(mean(WGCNAtpm[c("HIB_06830"),1:4]), mean(WGCNAtpm[c("HIB_06830"),5:8]), mean(WGCNAtpm[c("HIB_06830"),9:12]), mean(WGCNAtpm[c("HIB_06830"),13:16]), mean(WGCNAtpm[c("HIB_06830"),17:20]),  mean(WGCNAtpm[c("HIB_06830"),21:24]))

GeneMean[[4]] = rbind(mean(WGCNAtpm[c("HIB_06820"),1:4]), mean(WGCNAtpm[c("HIB_06820"),5:8]), mean(WGCNAtpm[c("HIB_06820"),9:12]), mean(WGCNAtpm[c("HIB_06820"),13:16]), mean(WGCNAtpm[c("HIB_06820"),17:20]),  mean(WGCNAtpm[c("HIB_06820"),21:24]))

GeneMean[[5]] = rbind(mean(WGCNAtpm[c("HIB_06790"),1:4]), mean(WGCNAtpm[c("HIB_06790"),5:8]), mean(WGCNAtpm[c("HIB_06790"),9:12]), mean(WGCNAtpm[c("HIB_06790"),13:16]), mean(WGCNAtpm[c("HIB_06790"),17:20]),  mean(WGCNAtpm[c("HIB_06790"),21:24]))

GeneMean[[6]] = rbind(mean(WGCNAtpm[c("HIB_06910"),1:4]), mean(WGCNAtpm[c("HIB_06910"),5:8]), mean(WGCNAtpm[c("HIB_06910"),9:12]), mean(WGCNAtpm[c("HIB_06910"),13:16]), mean(WGCNAtpm[c("HIB_06910"),17:20]),  mean(WGCNAtpm[c("HIB_06910"),21:24]))

GeneMean[[7]] = rbind(mean(WGCNAtpm[c("HIB_12720"),1:4]), mean(WGCNAtpm[c("HIB_12720"),5:8]), mean(WGCNAtpm[c("HIB_12720"),9:12]), mean(WGCNAtpm[c("HIB_12720"),13:16]), mean(WGCNAtpm[c("HIB_12720"),17:20]),  mean(WGCNAtpm[c("HIB_12720"),21:24]))

GeneMean[[8]] = rbind(mean(WGCNAtpm[c("HIB_12710"),1:4]), mean(WGCNAtpm[c("HIB_12710"),5:8]), mean(WGCNAtpm[c("HIB_12710"),9:12]), mean(WGCNAtpm[c("HIB_12710"),13:16]), mean(WGCNAtpm[c("HIB_12710"),17:20]),  mean(WGCNAtpm[c("HIB_12710"),21:24]))

GeneMean[[9]] = rbind(mean(WGCNAtpm[c("HIB_11930"),1:4]), mean(WGCNAtpm[c("HIB_11930"),5:8]), mean(WGCNAtpm[c("HIB_11930"),9:12]), mean(WGCNAtpm[c("HIB_11930"),13:16]), mean(WGCNAtpm[c("HIB_11930"),17:20]),  mean(WGCNAtpm[c("HIB_11930"),21:24]))

GeneMean[[10]] = rbind(mean(WGCNAtpm[c("HIB_05940"),1:4]), mean(WGCNAtpm[c("HIB_05940"),5:8]), mean(WGCNAtpm[c("HIB_05940"),9:12]), mean(WGCNAtpm[c("HIB_05940"),13:16]), mean(WGCNAtpm[c("HIB_05940"),17:20]),  mean(WGCNAtpm[c("HIB_05940"),21:24]))

for (i in 1:length(GeneMean)){
  rownames(GeneMean[[i]]) = c("S01", "S02", "S03", "S04", "S05", "S06")
}

Genesd[[1]] = rbind(sd(WGCNAtpm[c("HIB_14020"),1:4]), sd(WGCNAtpm[c("HIB_14020"),5:8]), sd(WGCNAtpm[c("HIB_14020"),9:12]), sd(WGCNAtpm[c("HIB_14020"),13:16]), sd(WGCNAtpm[c("HIB_14020"),17:20]),  sd(WGCNAtpm[c("HIB_14020"),21:24]))

Genesd[[2]] = rbind(sd(WGCNAtpm[c("HIB_13620"),1:4]), sd(WGCNAtpm[c("HIB_13620"),5:8]), sd(WGCNAtpm[c("HIB_13620"),9:12]), sd(WGCNAtpm[c("HIB_13620"),13:16]), sd(WGCNAtpm[c("HIB_13620"),17:20]),  sd(WGCNAtpm[c("HIB_13620"),21:24]))

Genesd[[3]] = rbind(sd(WGCNAtpm[c("HIB_06830"),1:4]), sd(WGCNAtpm[c("HIB_06830"),5:8]), sd(WGCNAtpm[c("HIB_06830"),9:12]), sd(WGCNAtpm[c("HIB_06830"),13:16]), sd(WGCNAtpm[c("HIB_06830"),17:20]),  sd(WGCNAtpm[c("HIB_06830"),21:24]))

Genesd[[4]] = rbind(sd(WGCNAtpm[c("HIB_06820"),1:4]), sd(WGCNAtpm[c("HIB_06820"),5:8]), sd(WGCNAtpm[c("HIB_06820"),9:12]), sd(WGCNAtpm[c("HIB_06820"),13:16]), sd(WGCNAtpm[c("HIB_06820"),17:20]),  sd(WGCNAtpm[c("HIB_06820"),21:24]))

Genesd[[5]] = rbind(sd(WGCNAtpm[c("HIB_06790"),1:4]), sd(WGCNAtpm[c("HIB_06790"),5:8]), sd(WGCNAtpm[c("HIB_06790"),9:12]), sd(WGCNAtpm[c("HIB_06790"),13:16]), sd(WGCNAtpm[c("HIB_06790"),17:20]),  sd(WGCNAtpm[c("HIB_06790"),21:24]))

Genesd[[6]] = rbind(sd(WGCNAtpm[c("HIB_06910"),1:4]), sd(WGCNAtpm[c("HIB_06910"),5:8]), sd(WGCNAtpm[c("HIB_06910"),9:12]), sd(WGCNAtpm[c("HIB_06910"),13:16]), sd(WGCNAtpm[c("HIB_06910"),17:20]),  sd(WGCNAtpm[c("HIB_06910"),21:24]))

Genesd[[7]] = rbind(sd(WGCNAtpm[c("HIB_12720"),1:4]), sd(WGCNAtpm[c("HIB_12720"),5:8]), sd(WGCNAtpm[c("HIB_12720"),9:12]), sd(WGCNAtpm[c("HIB_12720"),13:16]), sd(WGCNAtpm[c("HIB_12720"),17:20]),  sd(WGCNAtpm[c("HIB_12720"),21:24]))

Genesd[[8]] = rbind(sd(WGCNAtpm[c("HIB_12710"),1:4]), sd(WGCNAtpm[c("HIB_12710"),5:8]), sd(WGCNAtpm[c("HIB_12710"),9:12]), sd(WGCNAtpm[c("HIB_12710"),13:16]), sd(WGCNAtpm[c("HIB_12710"),17:20]),  sd(WGCNAtpm[c("HIB_12710"),21:24]))

Genesd[[9]] = rbind(sd(WGCNAtpm[c("HIB_11930"),1:4]), sd(WGCNAtpm[c("HIB_11930"),5:8]), sd(WGCNAtpm[c("HIB_11930"),9:12]), sd(WGCNAtpm[c("HIB_11930"),13:16]), sd(WGCNAtpm[c("HIB_11930"),17:20]),  sd(WGCNAtpm[c("HIB_11930"),21:24]))

Genesd[[10]] = rbind(sd(WGCNAtpm[c("HIB_05940"),1:4]), sd(WGCNAtpm[c("HIB_05940"),5:8]), sd(WGCNAtpm[c("HIB_05940"),9:12]), sd(WGCNAtpm[c("HIB_05940"),13:16]), sd(WGCNAtpm[c("HIB_05940"),17:20]),  sd(WGCNAtpm[c("HIB_05940"),21:24]))

Genestd.error[[1]] = rbind(std.error(WGCNAtpm[c("HIB_14020"),1:4]), std.error(WGCNAtpm[c("HIB_14020"),5:8]), std.error(WGCNAtpm[c("HIB_14020"),9:12]), std.error(WGCNAtpm[c("HIB_14020"),13:16]), std.error(WGCNAtpm[c("HIB_14020"),17:20]),  std.error(WGCNAtpm[c("HIB_14020"),21:24]))

Genestd.error[[2]] = rbind(std.error(WGCNAtpm[c("HIB_13620"),1:4]), std.error(WGCNAtpm[c("HIB_13620"),5:8]), std.error(WGCNAtpm[c("HIB_13620"),9:12]), std.error(WGCNAtpm[c("HIB_13620"),13:16]), std.error(WGCNAtpm[c("HIB_13620"),17:20]),  std.error(WGCNAtpm[c("HIB_13620"),21:24]))

Genestd.error[[3]] = rbind(std.error(WGCNAtpm[c("HIB_06830"),1:4]), std.error(WGCNAtpm[c("HIB_06830"),5:8]), std.error(WGCNAtpm[c("HIB_06830"),9:12]), std.error(WGCNAtpm[c("HIB_06830"),13:16]), std.error(WGCNAtpm[c("HIB_06830"),17:20]),  std.error(WGCNAtpm[c("HIB_06830"),21:24]))

Genestd.error[[4]] = rbind(std.error(WGCNAtpm[c("HIB_06820"),1:4]), std.error(WGCNAtpm[c("HIB_06820"),5:8]), std.error(WGCNAtpm[c("HIB_06820"),9:12]), std.error(WGCNAtpm[c("HIB_06820"),13:16]), std.error(WGCNAtpm[c("HIB_06820"),17:20]),  std.error(WGCNAtpm[c("HIB_06820"),21:24]))

Genestd.error[[5]] = rbind(std.error(WGCNAtpm[c("HIB_06790"),1:4]), std.error(WGCNAtpm[c("HIB_06790"),5:8]), std.error(WGCNAtpm[c("HIB_06790"),9:12]), std.error(WGCNAtpm[c("HIB_06790"),13:16]), std.error(WGCNAtpm[c("HIB_06790"),17:20]),  std.error(WGCNAtpm[c("HIB_06790"),21:24]))

Genestd.error[[6]] = rbind(std.error(WGCNAtpm[c("HIB_06910"),1:4]), std.error(WGCNAtpm[c("HIB_06910"),5:8]), std.error(WGCNAtpm[c("HIB_06910"),9:12]), std.error(WGCNAtpm[c("HIB_06910"),13:16]), std.error(WGCNAtpm[c("HIB_06910"),17:20]),  std.error(WGCNAtpm[c("HIB_06910"),21:24]))

Genestd.error[[7]] = rbind(std.error(WGCNAtpm[c("HIB_12720"),1:4]), std.error(WGCNAtpm[c("HIB_12720"),5:8]), std.error(WGCNAtpm[c("HIB_12720"),9:12]), std.error(WGCNAtpm[c("HIB_12720"),13:16]), std.error(WGCNAtpm[c("HIB_12720"),17:20]),  std.error(WGCNAtpm[c("HIB_12720"),21:24]))

Genestd.error[[8]] = rbind(std.error(WGCNAtpm[c("HIB_12710"),1:4]), std.error(WGCNAtpm[c("HIB_12710"),5:8]), std.error(WGCNAtpm[c("HIB_12710"),9:12]), std.error(WGCNAtpm[c("HIB_12710"),13:16]), std.error(WGCNAtpm[c("HIB_12710"),17:20]),  std.error(WGCNAtpm[c("HIB_12710"),21:24]))

Genestd.error[[9]] = rbind(std.error(WGCNAtpm[c("HIB_11930"),1:4]), std.error(WGCNAtpm[c("HIB_11930"),5:8]), std.error(WGCNAtpm[c("HIB_11930"),9:12]), std.error(WGCNAtpm[c("HIB_11930"),13:16]), std.error(WGCNAtpm[c("HIB_11930"),17:20]),  std.error(WGCNAtpm[c("HIB_11930"),21:24]))

Genestd.error[[10]] = rbind(std.error(WGCNAtpm[c("HIB_12720"),1:4]), std.error(WGCNAtpm[c("HIB_12720"),5:8]), std.error(WGCNAtpm[c("HIB_12720"),9:12]), std.error(WGCNAtpm[c("HIB_12720"),13:16]), std.error(WGCNAtpm[c("HIB_12720"),17:20]),  std.error(WGCNAtpm[c("HIB_12720"),21:24]))

Genestd.error[[11]] = rbind(std.error(WGCNAtpm[c("HIB_12710"),1:4]), std.error(WGCNAtpm[c("HIB_12710"),5:8]), std.error(WGCNAtpm[c("HIB_12710"),9:12]), std.error(WGCNAtpm[c("HIB_12710"),13:16]), std.error(WGCNAtpm[c("HIB_12710"),17:20]),  std.error(WGCNAtpm[c("HIB_12710"),21:24]))

for (i in 1:length(GeneMean)){
  CI.up[[i]] = as.numeric(GeneMean[[i]][,1])+as.numeric(Genestd.error[[i]][,1])
  CI.dn[[i]] = as.numeric(GeneMean[[i]][,1])-as.numeric(Genestd.error[[i]][,1])
}

a = 1:6
b = a+.1
c = a+.2
names(a) = c("S01", "S02", "S03", "S04", "S05", "S06")
```


# Diagnostics: displaying acetate production genes line plots
```{r, fig.width=7, fig.height=7}
library("plotrix")

GeneSignificance[[12]]["HIB_14020"]
GeneSignificance[[12]]["HIB_13620"]

for(i in 1:length(moduleblocks)){
  if ("HIB_13620" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# boxplot(WGCNAtpm[c("HIB_14020"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_14020", at =c(1, 3, 5, 7, 9, 11), col=which.module[[3]])
# boxplot(WGCNAtpm[c("HIB_13620"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_13620", at =c(1, 3, 5, 7, 9, 11), col=which.module[[4]])

max_y = max(CI.up[[1]], CI.up[[2]])

par(mar=c(5, 4.2, 3, 0.7) + 0.1, cex.axis=1.5,cex.lab=1.2)
plot(a, GeneMean[[1]][,1], axes=F, xlab="", ylab="",type="o", ylim=c(0,max_y),col="purple", main="", lty = 1)
points(GeneMean[[1]][,1],pch=21,col="purple")
points(b, GeneMean[[2]][,1],pch=21,col="blue")
lines(b, GeneMean[[2]][,1],pch=21,col="blue")
arrows(a,CI.dn[[1]],a,CI.up[[1]],code=3,length=0.1,angle=90,col='purple')
arrows(b,CI.dn[[2]],b,CI.up[[2]],code=3,length=0.1,angle=90,col='blue')
axis(2, ylim=c(0,max_y),col="black",lwd=2)
mtext(2,text="(Número de fragmentos, normalizados)",line=2.5, cex=1.5) #line controls the distance from the plot area.
axis(1, ylim=c(0,10), at=c(1.1, 2.1, 3.1, 4.1, 5.1, 6.1), labels = c("S01", "S02", "S03", "S04", "S05", "S06"))
mtext("Amostras",side=1,col="black",line=2.5, cex=1.5)
legend("bottomright", cex = 0.7, legend = c("HIB_14020", "HIB_13620"), col=c("purple", "blue"), pch=21, lty=1)
abline(h=mean(WGCNAtpm), col="black")
```


# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
par(mfrow=c(1,3), mar=c(5, 4.2, 3, 0.7), cex.axis=1.5,cex.lab=1.2)

for(i in 1:length(moduleblocks)){
  if ("HIB_06790" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_06830"]
GeneSignificance[[13]]["HIB_06820"]
GeneSignificance[[13]]["HIB_06790"]

boxplot(WGCNAtpm[c("HIB_06830"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_06830", at =c(1, 3, 5, 7, 9, 11), col=which.module[[2]])
boxplot(WGCNAtpm[c("HIB_06820"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_06820", at =c(1, 3, 5, 7, 9, 11), col=which.module[[1]])
boxplot(WGCNAtpm[c("HIB_06790"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_06790", at =c(1, 3, 5, 7, 9, 11), col=which.module[[3]])

# min_y = min(WGCNAtpm)
# max_y = max(max(WGCNAtpm["HIB_06830",]), max(WGCNAtpm["HIB_06820",]), max(WGCNAtpm["HIB_06790",]))
# 
# plot(1:24, WGCNAtpm["HIB_06830",], col=which.module[[2]], type="l", main="", cex.main=2, ylab="Express?o do gene", cex.lab = 1.5, xlim=c(1,24), xlab="", ylim=c(min_y, max_y), xaxt='n')
# axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
# lines(1:24, WGCNAtpm["HIB_06820",], col=which.module[[1]])
# lines(1:24, WGCNAtpm["HIB_06790",], col=which.module[[3]])
# legend("topleft", lty=1, legend=c(expression(italic("hib_06830")), expression(italic("hib_06820")), expression(italic("hib_06790"))), cex=0.5, col=c(which.module[[2]], which.module[[1]], which.module[[3]]))
```

# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
# par(mfrow=c(1,3), mar=c(5, 4.2, 3, 0.7), cex.axis=1.5,cex.lab=1.2)

for(i in 1:length(moduleblocks)){
  if ("HIB_06830" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_06830"]
GeneSignificance[[13]]["HIB_06820"]
GeneSignificance[[13]]["HIB_06790"]

max_y = max(CI.up[[3]], CI.up[[4]], CI.up[[5]])

par(mar=c(5, 4.2, 3, 0.7) + 0.1, cex.axis=1.5,cex.lab=1.2)
plot(a, GeneMean[[3]][,1], axes=F, xlab="", ylab="",type="o", ylim=c(0,max_y),col="black", main="", lty = 1)
points(a, GeneMean[[3]][,1],pch=21,col="black")
points(b, GeneMean[[4]][,1],pch=21,col="brown")
points(c, GeneMean[[5]][,1],pch=21,col="purple")
lines(b, GeneMean[[4]][,1],pch=21,col="brown")
lines(c, GeneMean[[5]][,1],pch=21,col="purple")
arrows(a,CI.dn[[3]],a,CI.up[[3]],code=3,length=0.1,angle=90,col='black')
arrows(b,CI.dn[[4]],b,CI.up[[4]],code=3,length=0.1,angle=90,col='brown')
arrows(c,CI.dn[[5]],c,CI.up[[5]],code=3,length=0.1,angle=90,col='purple')
axis(2, ylim=c(0,max_y),col="black",lwd=2)
mtext(2,text="(Número de fragmentos, normalizados)",line=2.5, cex=1.5) #line controls the distance from the plot area.
axis(1,ylim=c(0,max(c)), at=c(1.1, 2.1, 3.1, 4.1, 5.1, 6.1), labels = c("S01", "S02", "S03", "S04", "S05", "S06"))
mtext("Amostras",side=1,col="black",line=2.5, cex=1.5)
legend("bottomright", cex = 0.7, legend = c("HIB_06830", "HIB_06820", "HIB_06790"), col=c("black", "brown", "purple"), pch=21, lty=1)
abline(h=mean(WGCNAtpm), col="black")
```

# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
par(mfrow=c(1,3), mar=c(5, 4.2, 3, 0.7), cex.axis=1.5,cex.lab=1.2)

for(i in 1:length(moduleblocks)){
  if ("HIB_12710" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_06910"]
GeneSignificance[[13]]["HIB_12720"]
GeneSignificance[[13]]["HIB_12710"]

boxplot(WGCNAtpm[c("HIB_06910"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_06910", at =c(1, 3, 5, 7, 9, 11), col=which.module[[1]])
boxplot(WGCNAtpm[c("HIB_12720"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_12720", at =c(1, 3, 5, 7, 9, 11), col=which.module[[4]])
boxplot(WGCNAtpm[c("HIB_12710"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_12710", at =c(1, 3, 5, 7, 9, 11), col=which.module[[5]])


# min_y = min(WGCNAtpm)
# max_y = max(max(WGCNAtpm["HIB_06910",]), max(WGCNAtpm["HIB_12720",]), max(WGCNAtpm["HIB_12710",]))
# 
# plot(1:24, WGCNAtpm["HIB_06910",], col=which.module[[1]], type="l", main="", cex.main=2, ylab="Express?o do gene", cex.lab = 1.5, xlim=c(1,24), xlab="", ylim=c(min_y, max_y), xaxt='n')
# axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
# lines(1:24, WGCNAtpm["HIB_12720",], col=which.module[[4]])
# lines(1:24, WGCNAtpm["HIB_12710",], col=which.module[[5]])
# legend("topleft", lty=1, legend=c(expression(italic("HIB_06910")), expression(italic("HIB_12720")), expression(italic("HIB_12710"))), cex=0.5, col=c(which.module[[1]], which.module[[4]], which.module[[5]]))
```

# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}

for(i in 1:length(moduleblocks)){
  if ("HIB_12710" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_06910"]
GeneSignificance[[13]]["HIB_12720"]
GeneSignificance[[13]]["HIB_12710"]

max_y = max(CI.up[[6]], CI.up[[7]], CI.up[[8]])

par(mar=c(5, 4.2, 3, 0.7) + 0.1, cex.axis=1.5,cex.lab=1.2)
plot(a, GeneMean[[6]][,1], axes=F, xlab="", ylab="",type="o", ylim=c(0,max_y),col="brown", main="", lty = 1)
points(a, GeneMean[[6]][,1],pch=21,col="brown")
points(b, GeneMean[[7]][,1],pch=21,col="blue")
points(c, GeneMean[[8]][,1],pch=21,col="red")
lines(b, GeneMean[[7]][,1],pch=21,col="blue")
lines(c, GeneMean[[8]][,1],pch=21,col="red")
arrows(a,CI.dn[[6]],a,CI.up[[6]],code=3,length=0.1,angle=90,col='brown')
arrows(b,CI.dn[[7]],b,CI.up[[7]],code=3,length=0.1,angle=90,col='blue')
arrows(c,CI.dn[[8]],c,CI.up[[8]],code=3,length=0.1,angle=90,col='red')
axis(2, ylim=c(0,max_y),col="black",lwd=2)
mtext(2,text="(Número de fragmentos, normalizados)",line=2.5, cex=1.5) #line controls the distance from the plot area.
axis(1,ylim=c(0,7), at=c(1.1, 2.1, 3.1, 4.1, 5.1, 6.1), labels = c("S01", "S02", "S03", "S04", "S05", "S06"))
mtext("Amostras",side=1,col="black",line=2.5, cex=1.5)
legend("bottomright", cex = 0.7, legend = c("HIB_06910", "HIB_12720", "HIB_12710"), col=c("brown", "blue", "red"), pch=21, lty=1)

```


# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
par(mfrow=c(1,3), mar=c(5, 4.2, 3, 0.7), cex.axis=1.5,cex.lab=1.2)

for(i in 1:length(moduleblocks)){
  if ("HIB_05940" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_11930"]
GeneSignificance[[13]]["HIB_06910"]
GeneSignificance[[13]]["HIB_05940"]

boxplot(WGCNAtpm[c("HIB_11930"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_11930", at =c(1, 3, 5, 7, 9, 11), col=which.module[[1]])
boxplot(WGCNAtpm[c("HIB_06910"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_06910", at =c(1, 3, 5, 7, 9, 11), col=which.module[[7]])
boxplot(WGCNAtpm[c("HIB_05940"),]~HibDesign2[,1], ylab="Expressão do gene", xlab = "Amostras", main="HIB_05940", at =c(1, 3, 5, 7, 9, 11), col=which.module[[5]])

# min_y = min(WGCNAtpm)
# max_y = max(max(WGCNAtpm["HIB_06910",]), max(WGCNAtpm["HIB_11930",]), max(WGCNAtpm["HIB_05940",]))
# 
# plot(1:24, WGCNAtpm["HIB_06910",], col="black", type="l", main="", cex.main=2, ylab="Express?o do gene", cex.lab = 1.5, xlim=c(1,24), xlab="", ylim=c(min_y, max_y), xaxt='n')
# axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
# lines(1:24, WGCNAtpm["HIB_11930",], col="green")
# lines(1:24, WGCNAtpm["HIB_05940",], col="red")
# legend("topright", lty=1, legend=c(expression(italic("HIB_06910")), expression(italic("HIB_11930")), expression(italic("HIB_05940"))), cex=0.5, col=c("black", "green", "red"))
```

# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}

for(i in 1:length(moduleblocks)){
  if ("HIB_06910" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_06910"]
GeneSignificance[[13]]["HIB_11930"]
GeneSignificance[[13]]["HIB_05940"]

max_y = max(CI.up[[6]], CI.up[[9]], CI.up[[10]])

par(mar=c(5, 4.2, 3, 0.7) + 0.1, cex.axis=1.5,cex.lab=1.2)
plot(a, GeneMean[[6]][,1], axes=F, xlab="", ylab="",type="o", ylim=c(0,max_y),col="red", main="", lty = 1)
points(a, GeneMean[[6]][,1],pch=21,col="red")
points(b, GeneMean[[9]][,1],pch=21,col="blue")
points(c, GeneMean[[10]][,1],pch=21,col="gold")
lines(b, GeneMean[[9]][,1],pch=21,col="blue")
lines(c, GeneMean[[10]][,1],pch=21,col="gold")
arrows(a,CI.dn[[6]],a,CI.up[[6]],code=3,length=0.1,angle=90,col='red')
arrows(b,CI.dn[[9]],b,CI.up[[9]],code=3,length=0.1,angle=90,col='blue')
arrows(c,CI.dn[[10]],c,CI.up[[10]],code=3,length=0.1,angle=90,col='gold')
axis(2, ylim=c(0,max_y),col="black",lwd=2)
mtext(2,text="(Número de fragmentos, normalizados)",line=2.5, cex=1.5) #line controls the distance from the plot area.
axis(1,ylim=c(0,7), at=c(1.1, 2.1, 3.1, 4.1, 5.1, 6.1), labels = c("S01", "S02", "S03", "S04", "S05", "S06"))
mtext("Amostras",side=1,col="black",line=2.5, cex=1.5)
legend("topright", cex = 0.7, legend = c("HIB_06910", "HIB_11930", "HIB_05940"), col=c("red", "blue", "gold"), pch=21, lty=1)
abline(h=mean(WGCNAtpm), col="black")
```


# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
for(i in 1:length(moduleblocks)){
  if ("HIB_06910" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_11930"] #9
GeneSignificance[[13]]["HIB_06910"] #6
GeneSignificance[[13]]["HIB_05940"] #10

max_y = max(CI.up[[9]], CI.up[[6]], CI.up[[10]])

par(mar=c(5, 4.2, 3, 0.7) + 0.1, cex.axis=1.5,cex.lab=1.2)
plot(a, GeneMean[[6]][,1], axes=F, xlab="", ylab="",type="o", ylim=c(0,max_y),col="brown", main="", lty = 1)
points(a, GeneMean[[6]][,1],pch=21,col="brown")
points(b, GeneMean[[9]][,1],pch=21,col="blue")
points(c, GeneMean[[10]][,1],pch=21,col="gold3")
lines(b, GeneMean[[9]][,1],pch=21,col="blue")
lines(c, GeneMean[[10]][,1],pch=21,col="gold3")
arrows(a,CI.dn[[6]],a,CI.up[[6]],code=3,length=0.1,angle=90,col='brown')
arrows(b,CI.dn[[9]],b,CI.up[[9]],code=3,length=0.1,angle=90,col='blue')
arrows(c,CI.dn[[10]],c,CI.up[[10]],code=3,length=0.1,angle=90,col='gold3')
axis(2, ylim=c(0,max_y),col="black",lwd=2)
mtext(2,text="(Número de fragmentos, normalizados)",line=2.5, cex=1.5) #line controls the distance from the plot area.
axis(1,ylim=c(0,7), at=c(1.1, 2.1, 3.1, 4.1, 5.1, 6.1), labels = c("S01", "S02", "S03", "S04", "S05", "S06"))
mtext("Amostras",side=1,col="black",line=2.5, cex=1.5)
legend("topright", cex = 0.7, legend = c("HIB_06910", "HIB_11930", "HIB_05940"), col=c("brown", "blue", "gold3"), pch=21, lty=1) 
```


# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
#par(mfrow=c(3,3), mar=c(0.3, 5.5, 3, 2))
par(mar=c(5, 4.2, 0, 0.7))

for(i in 1:length(moduleblocks)){
  if ("HIB_11670" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_11690"]
GeneSignificance[[13]]["HIB_11680"]
GeneSignificance[[13]]["HIB_11670"]
GeneSignificance[[13]]["HIB_11660"]

min_y = min(WGCNAtpm)
max_y = max(max(WGCNAtpm["HIB_11690",]), max(WGCNAtpm["HIB_11680",]), max(WGCNAtpm["HIB_11670",]), max(WGCNAtpm["HIB_11660",]))

plot(1:24, WGCNAtpm["HIB_11660",], col=which.module[[4]], type="l", main="", cex.main=2, ylab="Express?o do gene", cex.lab = 1.5, xlim=c(1,24), xlab="", ylim=c(min_y, max_y), xaxt='n')
axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
lines(1:24, WGCNAtpm["HIB_11670",], col=which.module[[1]])
lines(1:24, WGCNAtpm["HIB_11680",], col=which.module[[1]])
lines(1:24, WGCNAtpm["HIB_11690",], col=which.module[[4]])
legend("topleft", lty=1, legend=c(expression(italic("hib_11660")), expression(italic("hib_11670")), expression(italic("hib_11680")), expression(italic("hib_11690"))), cex=0.5, col=c(which.module[[4]], which.module[[1]], which.module[[1]], which.module[[4]]))
```

# Diagnostics: displaying PRP production genes line plots
```{r, fig.width=7, fig.height=7}
#par(mfrow=c(3,3), mar=c(0.3, 5.5, 3, 2))
par(mar=c(5, 4.2, 0, 0.7))

for(i in 1:length(moduleblocks)){
  if ("HIB_11840" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

GeneSignificance[[13]]["HIB_11840"]
GeneSignificance[[13]]["HIB_11830"]
GeneSignificance[[13]]["HIB_11820"]
GeneSignificance[[13]]["HIB_11810"]

min_y = min(WGCNAtpm)
max_y = max(max(WGCNAtpm["HIB_11840",]), max(WGCNAtpm["HIB_11830",]), max(WGCNAtpm["HIB_11820",]), max(WGCNAtpm["HIB_11810",]))

plot(1:24, WGCNAtpm["HIB_11840",], col=which.module[[4]], type="l", main="", cex.main=2, ylab="Express?o do gene", cex.lab = 1.5, xlim=c(1,24), xlab="", ylim=c(min_y, max_y), xaxt='n')
axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
lines(1:24, WGCNAtpm["HIB_11830",], col=which.module[[4]])
lines(1:24, WGCNAtpm["HIB_11820",], col=which.module[[4]])
lines(1:24, WGCNAtpm["HIB_11810",], col=which.module[[4]])
legend("bottomright", lty=1, legend=c(expression(italic("hib_11840")), expression(italic("hib_11830")), expression(italic("hib_11820")), expression(italic("hib_11810"))), cex=0.5, col=c(which.module[[4]], which.module[[4]], which.module[[4]], which.module[[4]]))
```




```{r, fig.width=10, fig.height=7}
library("clusterProfiler")
# spaghetti plot
plot(1:24, magenta[1,], col=which.module[[6]], type="l", main="", cex.main=2, ylab="Express?o do autogene", cex.lab = 1.5, xlim=c(1,24), xlab="",ylim=c(min_y, max_y), xaxt='n')
axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
title(xlab="Amostras", line=4, cex.lab=1.5)
for (i in 2:nrow(scaled[moduleColors==which.module[[6]],])){lines(1:24, magenta[i,], col=which.module[[6]])}
lines(1:24, ME[[6]],  col="black", type="l", lwd = 4)
```

```{r, fig.width=7, fig.height=14}
# spaghetti plot
par(mfrow=c(3,3), mar=rep(2, 4))
min_y = min(WGCNAtpm)
for (j in 1:length(which.module)){
max_y = max(WGCNAtpm[moduleColors==which.module[[j]],])
plot(1:24, WGCNAtpm[moduleColors==which.module[[j]],][1,], col=which.module[[j]], type="l", main="", cex.main=2, ylab="Expressão do gene", cex.lab = 1.5, xlim=c(1,24), xlab="",ylim=c(min_y, max_y), xaxt='n')
axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
title(xlab="Amostras", line=4, cex.lab=1.5)
for (i in 2:nrow(WGCNAtpm[moduleColors==which.module[[j]],])){lines(1:24, WGCNAtpm[moduleColors==which.module[[j]],][i,], col=which.module[[j]])}
}
```

```{r, fig.width=7, fig.height=14}
# spaghetti plot -> log expression
par(mfrow=c(3,3), mar=rep(2, 4))
min_y = min(WGCNAtpm)
for (j in 1:length(which.module)){
max_y = log(max(WGCNAtpm[moduleColors==which.module[[j]],]))
plot(1:24, log(WGCNAtpm[moduleColors==which.module[[j]],][1,]), type="l", main="", cex.main=2, ylab="Expressão do gene", cex.lab = 1.5, xlim=c(1,24), xlab="",ylim=c(min_y, max_y), xaxt='n')
axis = axis(side=1, at = 1:24, labels = rownames(datExpr),las = 2)
title(xlab="Amostras", line=4, cex.lab=1.5)
for (i in 2:nrow(WGCNAtpm[moduleColors==which.module[[j]],])){lines(1:24, log(WGCNAtpm[moduleColors==which.module[[j]],][i,]))}
}
```

```{r, fig.width=7, fig.height=14}

```






# Check in which modules are genes for Transcription Factors
```{r, message=FALSE}

regulators = grep("regulator", RefSeqgff.genes$product)

OldLocusTag_regulators = RefSeqgff.genes$OldLocusTag[grep("regulator", RefSeqgff.genes$product)]

NewLocusTag_regulators = RefSeqgff.genes$Name[grep("regulator", RefSeqgff.genes$product)]
```

# Check if genes for polysaccharide synthesis are in the same module
```{r, meddage=FALSE}
# Polysaccharide polymerase (HIB_10030) (HIB_RS05310)
for(i in 1:length(moduleblocks)){
  if ("HIB_10030" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# short-chain dehydrogenases/reductases family protein - ribitol-5-phosphate 2-dehydrogenase (NADP+) / D-ribitol-5-phosphate cytidylyltransferase (bcs1) (HIB_11690) (HIB_RS06115)
for(i in 1:length(moduleblocks)){
  if ("HIB_11690" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# short-chain dehydrogenases/reductases family protein - ribitol-5-phosphate 2-dehydrogenase (NADP+) / D-ribitol-5-phosphate cytidylyltransferase (bcs1) (HIB_11840) (HIB_RS06180)
for(i in 1:length(moduleblocks)){
  if ("HIB_11840" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase - dna for serotype b capsulation locus (bcs2) (HIB_11830) (HIB_RS06175)
for(i in 1:length(moduleblocks)){
  if ("HIB_11830" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase - dna for serotype b capsulation locus (bcs2) (HIB_11680) (HIB_RS06110)
for(i in 1:length(moduleblocks)){
  if ("HIB_11680" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase (bcs3) (HIB_11670) (HIB_RS06105)
for(i in 1:length(moduleblocks)){
  if ("HIB_11670" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# CDP-glycerol glycerophosphotransferase (bcs3) (HIB_11820) (HIB_RS06170)
for(i in 1:length(moduleblocks)){
  if ("HIB_11820" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide biosynthesis protein (bcs4) (HIB_11660) (HIB_RS06100)
for(i in 1:length(moduleblocks)){
  if ("HIB_11660" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide biosynthesis protein (bcs4) (HIB_11810) (HIB_RS06165)
for(i in 1:length(moduleblocks)){
  if ("HIB_11810" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}
```

# Check if genes polysaccharide related are in the same module
```{r, meddage=FALSE}
# ATP-binding protein (bexA)
for(i in 1:length(moduleblocks)){
  if ("HIB_11730" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide export inner-membrane protein (bexB)
for(i in 1:length(moduleblocks)){
  if ("HIB_11720" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide export inner-membrane protein (bexB)
for(i in 1:length(moduleblocks)){
  if ("HIB_11870" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide transporter - capsular polysaccharide transport system permease protein (bexC)
for(i in 1:length(moduleblocks)){
  if ("HIB_11710" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsule polysaccharide transporter - capsular polysaccharide transport system permease protein (bexC)
for(i in 1:length(moduleblocks)){
  if ("HIB_11860" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# sugar ABC transporter substrate-binding protein - polysaccharide biosynthesis/export protein (bexD)
for(i in 1:length(moduleblocks)){
  if ("HIB_11850" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsA)
for(i in 1:length(moduleblocks)){
  if ("HIB_11650" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsA)
for(i in 1:length(moduleblocks)){
  if ("HIB_11800" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsB)
for(i in 1:length(moduleblocks)){
  if ("HIB_11640" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# capsular polysaccharide export protein - capsule polysaccharide transporter (hcsB)
for(i in 1:length(moduleblocks)){
  if ("HIB_11790" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}
```

# Check if genes for TCA cycle are in the same module
```{r, meddage=FALSE}
# malate dehydrogenase (HIB_13680) (HIB_RS07095)
for(i in 1:length(moduleblocks)){
  if ("HIB_13680" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

#fumarate hydratase, class II (HIB_15690) (HIB_RS08095)
for(i in 1:length(moduleblocks)){
  if ("HIB_15690" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# fumarate reductase subunit D (HIB_09650) (HIB_RS05120)
for(i in 1:length(moduleblocks)){
  if ("HIB_09650" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# succinyl-CoA synthetase beta subunit) (HIB_13540) (HIB_RS07025)
for(i in 1:length(moduleblocks)){
  if ("HIB_06830" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}
```

# Check if genes for Transcription Factors are in the same module
```{r, meddage=FALSE}
# putative transcriptional regulator (HIB_00450) (HIB_RS00235)
for(i in 1:length(moduleblocks)){
  if ("HIB_10170" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# DNA-binding transcriptional regulator of rRNA transcription, DnaK suppressor protein (HIB_00550) (HIB_RS00285)
for(i in 1:length(moduleblocks)){
  if ("HIB_00550" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# DNA-binding transcriptional activator (HIB_01510) (HIB_RS00790)
for(i in 1:length(moduleblocks)){
  if ("HIB_01510" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# putative HTH-type transcriptional regulator (HIB_01960) (HIB_RS01075)
for(i in 1:length(moduleblocks)){
  if ("HIB_01960" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# regulator of penicillin binding proteins and beta lactamase transcription (morphogene) (HIB_02160) (HIB_RS01175)
for(i in 1:length(moduleblocks)){
  if ("HIB_02160" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# putative HTH-type transcriptional regulator (HIB_02370) (HIB_RS01280)
for(i in 1:length(moduleblocks)){
  if ("HIB_02370" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# DNA-binding transcriptional dual regulator (HIB_02420) (HIB_RS01305)
for(i in 1:length(moduleblocks)){
  if ("HIB_02420" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# 	bifunctional biotin-[acetylCoA carboxylase] holoenzyme synthetase/ DNA-binding transcriptional repressor, bio-5'-AMP-binding (HIB_02770) (HIB_RS01490)
for(i in 1:length(moduleblocks)){
  if ("HIB_02770" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# putative transcriptional regulator (HIB_02810) (HIB_RS01510)
for(i in 1:length(moduleblocks)){
  if ("HIB_02810" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}

# putative HTH-type transcriptional regulator (HIB_03450) (HIB_RS01280)
for(i in 1:length(moduleblocks)){
  if ("HIB_06830" %in% rownames(moduleblocks[[i]])==TRUE){
    print(i)
  }
}
```
